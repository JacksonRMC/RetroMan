{"version":3,"sources":["components/Board.tsx","util/assert.ts","components/StoreContext.ts","model/eatEnergizer.ts","pages/GamePage/components/EnergizerDebugView.tsx","pages/GamePage/components/GhostDebugControls.tsx","model/collisionDetection.ts","model/MazeData.ts","model/Coordinates.ts","model/detectCollisions.ts","model/Types.ts","model/Vector.ts","model/Ways.ts","model/getTileDistance.ts","model/chooseNewTargetTile.ts","model/chooseNextTile.ts","model/getDirectionFromTileToTile.ts","model/updateGhostStatePhase.ts","model/updateGhosts.ts","pages/GamePage/components/GhostDebugTable.tsx","components/Spacer.tsx","pages/GamePage/components/GhostsDebugView.tsx","pages/GamePage/components/PacManDebugView.tsx","pages/GamePage/components/GameDebugView.tsx","pages/GamePage/components/DebugView.tsx","components/Sprite.tsx","components/Box.tsx","model/pacManDyingPhase.ts","pages/GamePage/components/PacManView.tsx","pages/GamePage/components/ExtraLives.tsx","pages/GamePage/components/Message.tsx","pages/GamePage/components/GameOver.tsx","pages/WayFindingPage/WayPoint.tsx","pages/WayFindingPage/WayPoints.tsx","pages/GamePage/components/Target.tsx","pages/GamePage/components/GhostsView.tsx","pages/GamePage/components/MazeView.tsx","pages/GamePage/components/PillsView.tsx","pages/GamePage/components/Score.tsx","model/movePacManBy.ts","model/updatePacMan.ts","model/onAnimationFrame.ts","model/updateExternalTimeStamp.ts","model/updateGameTimestamp.ts","model/updateEnergizerTimer.ts","model/useGameLoop.ts","model/useAnimationLoop.ts","pages/GamePage/GamePage.tsx","pages/GamePage/components/useKeyboardActions.ts","components/Grid.tsx","pages/MazePage/MazePage.tsx","model/changeDirectionToOpposite.ts","model/findWayPoints.ts","model/GhostStateChart.ts","model/TimeoutTimer.ts","model/Ghost.ts","pages/SpritePage/SpritePage.tsx","pages/WayFindingPage/WayFindingPage.tsx","Routes.tsx","components/AppMenu.tsx","model/makeGhosts.ts","model/Maze.ts","model/PacManStateChart.ts","model/PacMan.ts","model/Game.ts","model/DebugState.ts","model/Store.ts","App.tsx","index.tsx"],"names":["Board","className","children","classNames","assert","condition","msg","Error","StoreContext","createContext","StoreProvider","Provider","useStore","store","useContext","useGame","game","eatEnergizer","action","score","killedGhosts","pacMan","send","ghosts","formatter","Intl","NumberFormat","minimumFractionDigits","maximumFractionDigits","EnergizerDebugView","observer","Layout","title","size","bordered","flex","format","Math","abs","energizerTimer","timeLeft","StyledButton","shape","onClick","styled","div","Button","Text","Typography","GhostDebugControls","checked","debugState","ghostViewOptions","target","onChange","wayPoints","collide","rect1","rect2","x","width","y","height","BASIC_PILL_ID","getLayer","layerName","layer","MapData","layers","find","name","pillsLayer","waysLayer","MAZE_WIDTH_IN_TILES","MAZE_HEIGHT_IN_TILES","getTileMatrix","data","tileMatrix","Array","dataIndex","ty","tx","tileId","getPillsMatrix","waysMatrix","SCALE_FACTOR","SCREEN_TILE_SIZE","SPRITE_TILE_SIZE","SCREEN_TILE_CENTER","SCREEN_TILE_CENTER_VECTOR","MAZE_WIDTH_IN_SCREEN_COORDINATES","MAZE_HEIGHT_IN_SCREEN_COORDINATES","MAZE_DIMENSIONS_IN_TILES","isTxValid","isTyValid","isValidTileCoordinates","tile","assertValidTileCoordinates","screenFromTileCoordinate","tileCoordinate","tileFromScreenCoordinate","screenCoordinate","floor","screenFromTile","tileFromScreen","screen","addCoordinatesAndVector","coordinates","vector","rectangleContainsTile","tileRectangle","tile1","tile2","wrapTileToBounds","bounds","getPillHitBox","pill","PILL_BOX_HIT_BOX_WIDTH","getPacManHitBox","PAC_MAN_HIT_BOX_WIDTH","PAC_MAN_HIT_BOX_HEIGHT","getGhostHitBox","GHOST_HIT_BOX_WIDTH","GHOST_HIT_BOX_HEIGHT","eatPillLayerObject","maze","pills","eatPill","console","error","ghostCollidesWithPacMan","ghost","detectCollisions","dead","pillTile","tileCoordinates","pillHitBox","pacManHitBox","screenCoordinates","detectPacManEatingPill","ghostHitBox","detectGhostCollisions","Directions","assertValidDirection","direction","includes","multiplyVector","factor","BOX_TILE_COORDINATES","BOX_SPACE_TILE_COORDINATES","isWayFreeAt","isTileCenter","DIRECTION_TO_VECTOR","RIGHT","LEFT","UP","DOWN","directionToVector","distance","moveFromTile","steps","step","newTile","DIRECTION_TO_OPPOSITE_DIRECTION","isWayFreeInDirection","stepSize","nextTile","getNextTile","DIRECTION_TO_TILE_VECTOR","scaledVector","movedTile","getTileDistance","neighbourTile","targetTile","dx","dy","sqrt","pow","TILE_FOR_LEAVING_THE_BOX","TILE_FOR_RETURNING_TO_BOX","SCATTER_TILE_FOR_GHOST_0","chooseInScatterMode","isInsideBoxWalls","ghostNumber","chooseForGhost2InChaseState","from","to","intermediateTile","chooseGhost2IntermediateTile","blinky","vectorToBlinky","rotatedVector","twoTilesAhead","choseInChaseMode","chooseForGhost0InChaseState","fourTilesAhead","chooseForGhost1InChaseState","chooseForGhost3InChaseState","chooseInFrightenedMode","chooseSomeRandomMovement","candidateDirections","filter","length","max","newDirection","random","chooseInDeadMode","chooseNextTile","currentTile","currentDirection","boxDoorIsOpen","toJS","bestNextTile","chooseBestNextTile","anyNextTile","chooseAnyNextTile","JSON","stringify","candidates","possibleNextTile","distanceToTarget","push","bestCandidate","minBy","neighbourTileInCurrentDirection","isWayFreeForGhostAt","TUNNEL_X_RIGHT","getDirectionFromTileToTile","tileFrom","tileTo","isEqual","updateGhostStatePhaseTime","statePhaseTimer","advance","lastFrameLength","updateGhostStatePhase","atTileCenter","isTimedOut","setDuration","getStatePhaseLength","state","restart","updateGhost","ghostPaused","updateDeadWaitingTimeInBoxLeft","routeAndMoveGhost","deadWaitingTimeInBoxLeft","reRouteGhost","moveGhost","chooseNewTargetTile","updateDirection","updateSpeed","getNewDirection","newSpeedFactor","getNewSpeedFactor","speedFactor","canPassThroughBoxDoor","getGhostMovementVector","moveGhostBy","speed","columns","align","render","Dot","color","colorCode","toString","stateChanges","PausedSwitch","KillButton","record","MoveButton","disabled","frightened","GhostsDebugTable","dataSource","pagination","rowKey","SIZE_MAPPING","small","medium","large","mappedSize","VSpace","GhostsDebugView","PacManDebugView","alive","ButtonStyled","revivePacMan","GameDebugView","gameViewOptions","hitBox","gamePaused","resetGame","DebugView","CardInline","Card","scale","Sprite","spriteName","style","position","left","top","transform","transformOrigin","Box","rect","backgroundColor","zIndex","PacManDyingPhases","keys","TotalPacManDyingAnimationLength","PacManDyingPhaseLength","PacManAnimationPhases","PacManView","pacManAnimationPhase","getPacManAnimationPhase","dyingPhase","timeSinceDeath","PacManDyingPhaseCount","getPacManDyingPhase","PAC_MAN_WIDTH","PAC_MAN_HEIGHT","dyingPacManAnimationPhase","round","timestamp","PacManSprite","DyingPacManSprite","PacManHitBox","ExtraLives","times","extraLivesLeft","n","Message","text","MessageStyled","span","GameOver","gameOver","POINTS","DirectionToAngle","WayPoint","angle","SvgStyled","viewBox","points","fill","stroke","strokeWidth","svg","WayPoints","map","wayPoint","index","getDirection","indexToUse","fromTile","toTile","Target","version","d","GhostsGameView","GhostsView","DefaultGhostViewOptions","DefaultGameViewOptions","GhostCompositeView","GhostView","animationPhase","frightenedGhostTime","ghostAnimationPhase","GHOST_WIDTH","GHOST_HEIGHT","GhostSprite","phase","DeadGhostSprite","FrightenedGhostSprite","GhostHitBox","MazeView","BasicPillView","EnergizerView","BasicPillHitBox","PillView","PillsView","memo","_","displayName","Score","movePacManBy","updateLivingPacMan","nextDirection","movePacMan","delta","directionAsVector","updateDeadPacMan","onAnimationFrame","externalTimeStamp","updateExternalTimestamp","frameCount","updateGameTimestamp","updateEnergizerTimer","updatePacMan","updateGhosts","useGameLoop","animationStep","requestRef","useRef","animate","current","requestAnimationFrame","useEffect","cancelAnimationFrame","useAnimationLoop","GamePage","onKeyDown","useCallback","event","pressedKey","key","document","addEventListener","removeEventListener","useKeyboardActions","data-testid","ScoreArea","justify","EmptyArea","BoardArea","DebugArea","GridWithHoverCoordinates","useState","setCoordinates","pillsMatrix","onHover","ROWS","Grid","gridTemplateColumns","gridTemplateRows","rowIndex","columnIndex","onMouseEnter","onMouseLeave","MazePage","RelativeAbsoluteLayout","changeDirectionToOpposite","findWayPoints","origin","destination","way","workingDirection","some","INITIAL_GHOST_STATE","GhostStateChart","Machine","id","initial","on","RESET","states","chase","ENERGIZER_EATEN","PHASE_END","actions","COLLISION_WITH_PAC_MAN","scatter","ENERGIZER_TIMED_OUT","REVIVED","TimeoutTimer","bound","duration","onTimedOut","this","running","timeSpent","timePassed","stop","start","observable","computed","GhostNumbers","GhostAnimationPhases","FrightenedGhostTimes","KILL_GHOST_SCORE","Ghost","ref","stateChart","eventHandler","extended","withConfig","onScatterToChase","onChaseToScatter","onDead","interpret","makeGhostStateChart","initialWaitingTimeInBox","onTransition","handleStateTransition","changed","stateChartState","value","matches","frightenedAboutToEnd","isOutsideBoxSpace","SpritePage","phaseCounter","setPhaseCounter","directionIndex","setDirectionIndex","pacManPhase","ghostPhase","timerId","setInterval","clearInterval","dyingPacManPhase","WayFindingPage","localStore","useLocalStore","setOrigin","setDestination","shiftKey","Routes","path","exact","AppMenu","location","useLocation","history","useHistory","selectedKey","pathname","MenuStyled","mode","selectedKeys","Item","Menu","resetGhosts","setTileCoordinates","resetGhost","Maze","INITIAL_PACMAN_STATE","PacManStateChart","eating","COLLISION_WITH_GHOST","chasing","entry","PacMan","onChasing","makePacManStateChart","handleTransition","diedAtTimestamp","resetPacMan","Game","handleEnergizerTimedOut","makeGhosts","DebugState","somePlaceholder","Store","readyGameForPlay","App","Router","BrowserRouter","ReactDOM","getElementById"],"mappings":"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","file":"static/js/main.cd309e73.chunk.js","sourcesContent":["import React from 'react';\nimport './Board.css';\nimport classNames from 'classnames';\n\nexport const Board: React.FC<{ className?: string }> = ({\n  className,\n  children,\n}) => <div className={classNames('Board', className)}>{children}</div>;\n","export function assert(condition: any, msg?: string): asserts condition {\n  if (!condition) {\n    throw new Error(`Assertion error ${msg ?? ''}`);\n  }\n}\n","import { createContext, useContext } from 'react';\nimport { Game } from '../model/Game';\nimport { assert } from '../util/assert';\nimport { Store } from '../model/Store';\n\nexport const StoreContext = createContext<Store | null>(null);\n\nexport const StoreProvider = StoreContext.Provider;\n\nexport const useStore = (): Store => {\n  const store = useContext(StoreContext);\n  assert(store, 'Store not provided - use <StoreProvider>');\n  return store;\n};\n\nexport const useGame = (): Game => {\n  const store = useStore();\n  return store.game;\n};\n","import { Game } from './Game';\nimport { action } from 'mobx';\n\nexport const ENERGIZER_POINTS = 30;\n\nexport const eatEnergizer = action((game: Game) => {\n  game.score += ENERGIZER_POINTS;\n  game.killedGhosts = 0;\n  game.pacMan.send('ENERGIZER_EATEN');\n  for (const ghost of game.ghosts) {\n    ghost.send('ENERGIZER_EATEN');\n  }\n});\n","import { Card, Button, Row, Col } from 'antd';\nimport { observer } from 'mobx-react-lite';\nimport React from 'react';\nimport styled from 'styled-components/macro';\nimport { useGame } from '../../../components/StoreContext';\nimport { eatEnergizer } from '../../../model/eatEnergizer';\n\nconst formatter = new Intl.NumberFormat('en-US', {\n  minimumFractionDigits: 1,\n  maximumFractionDigits: 1,\n});\n\nexport const EnergizerDebugView = observer<{ className?: string }>(\n  ({ className }) => {\n    const game = useGame();\n    return (\n      <Layout className=\"EnergizerDebugView\">\n        <Card title=\"Energizer\" size=\"small\" bordered={false}>\n          <Row>\n            <Col flex=\"0 0 200px\">\n              <div>\n                Time left:{' '}\n                {formatter.format(\n                  Math.abs(game.energizerTimer.timeLeft) / 1000\n                )}{' '}\n                seconds\n              </div>\n            </Col>\n\n            <Col flex=\"0 0 48px\"></Col>\n\n            <Col flex=\"0 0 80px\">\n              <StyledButton\n                size=\"small\"\n                shape=\"round\"\n                onClick={() => {\n                  eatEnergizer(game);\n                }}\n              >\n                Eat\n              </StyledButton>\n            </Col>\n          </Row>\n        </Card>\n      </Layout>\n    );\n  }\n);\n\nconst Layout = styled.div``;\n\nconst StyledButton = styled(Button)`\n  width: 80px;\n`;\n","import { Col, Row, Switch, Typography } from 'antd';\nimport { action } from 'mobx';\nimport { observer } from 'mobx-react-lite';\nimport React from 'react';\nimport { useStore } from '../../../components/StoreContext';\n\nconst { Text } = Typography;\n\nexport const GhostDebugControls = observer(() => {\n  const store = useStore();\n  return (\n    <div className=\"GhostDebugControls\">\n      <Row>\n        <Col flex=\"0 0 56px\">\n          <Switch\n            checked={store.debugState.ghostViewOptions.target}\n            onChange={action(checked => {\n              store.debugState.ghostViewOptions.target = checked;\n            })}\n          />\n        </Col>\n        <Col flex=\"0 0 auto\">\n          <Text>Show Target Tile</Text>\n        </Col>\n        <Col flex=\"0 0 56px\"></Col>\n\n        <Col flex=\"0 0 56px\">\n          <Switch\n            checked={store.debugState.ghostViewOptions.wayPoints}\n            onChange={action(checked => {\n              store.debugState.ghostViewOptions.wayPoints = checked;\n            })}\n          />\n        </Col>\n        <Col flex=\"0 0 auto\">\n          <Text>Show Waypoints</Text>\n        </Col>\n        <Col flex=\"0 0 56px\"></Col>\n      </Row>\n    </div>\n  );\n});\n","import { Rectangle } from './Rectangle';\n\nexport const collide = (rect1: Rectangle, rect2: Rectangle): boolean => {\n  return (\n    rect1.x < rect2.x + rect2.width &&\n    rect1.x + rect1.width > rect2.x &&\n    rect1.y < rect2.y + rect2.height &&\n    rect1.y + rect1.height > rect2.y\n  );\n};\n","import MapData from '../mapData/pacman6.json';\n\nexport type TileId = number;\n\nexport const EMPTY_TILE_ID: TileId = 0;\nexport const BASIC_PILL_ID: TileId = 3533;\nexport const ENERGIZER_ID: TileId = 3589;\n\nexport const WAY_FREE_ID: TileId = 5240;\nexport const BOX_DOOR_ID: TileId = 5241;\n\nexport type TileMatrix = TileId[][];\n\ninterface Layer {\n  data: number[];\n  width: number;\n  height: number;\n}\n\nconst getLayer = (layerName: string): Layer => {\n  const layer = MapData.layers.find(layer => layer.name === layerName);\n  if (!layer) {\n    throw new Error(`${layerName} layer not found`);\n  }\n  return layer;\n};\n\nconst pillsLayer: Layer = getLayer('Pills');\nconst waysLayer: Layer = getLayer('Ways');\n\nexport const MAZE_WIDTH_IN_TILES = pillsLayer.width;\nexport const MAZE_HEIGHT_IN_TILES = pillsLayer.height;\n\nexport const getTileMatrix = (data: TileId[]): TileMatrix => {\n  const tileMatrix: number[][] = Array(MAZE_HEIGHT_IN_TILES);\n  let dataIndex = 0;\n  for (let ty = 0; ty < MAZE_HEIGHT_IN_TILES; ty++) {\n    tileMatrix[ty] = Array(MAZE_WIDTH_IN_TILES);\n    for (let tx = 0; tx < MAZE_WIDTH_IN_TILES; tx++) {\n      const tileId = data[dataIndex];\n      tileMatrix[ty][tx] = tileId;\n      dataIndex++;\n    }\n  }\n  return tileMatrix;\n};\n\nexport const getPillsMatrix = (): TileMatrix => getTileMatrix(pillsLayer.data);\n\nexport const waysMatrix: TileMatrix = getTileMatrix(waysLayer.data);\n","import { MAZE_WIDTH_IN_TILES, MAZE_HEIGHT_IN_TILES } from './MazeData';\nimport { assert } from '../util/assert';\nimport { Vector } from './Vector';\n\nexport type Coordinate = number;\n\nexport type TileCoordinate = Coordinate;\nexport type ScreenCoordinate = Coordinate;\n\nexport interface TileCoordinates {\n  x: TileCoordinate;\n  y: TileCoordinate;\n}\n\nexport interface ScreenCoordinates {\n  x: ScreenCoordinate;\n  y: ScreenCoordinate;\n}\n\nexport type Coordinates = TileCoordinates | ScreenCoordinates;\n\nexport interface TileRectangle {\n  tile1: TileCoordinates;\n  tile2: TileCoordinates;\n}\n\nexport const SCALE_FACTOR = 2.5;\nexport const SPRITE_TILE_SIZE = 8;\nexport const SCREEN_TILE_SIZE = SPRITE_TILE_SIZE * SCALE_FACTOR;\nexport const SCREEN_TILE_CENTER = SCREEN_TILE_SIZE / 2;\n\nexport const SCREEN_TILE_CENTER_VECTOR: Vector = {\n  x: SCREEN_TILE_CENTER,\n  y: SCREEN_TILE_CENTER,\n};\n\nexport const MAZE_WIDTH_IN_SCREEN_COORDINATES =\n  MAZE_WIDTH_IN_TILES * SCREEN_TILE_SIZE;\nexport const MAZE_HEIGHT_IN_SCREEN_COORDINATES =\n  MAZE_HEIGHT_IN_TILES * SCREEN_TILE_SIZE;\n\nexport const MAZE_DIMENSIONS_IN_TILES: TileCoordinates = {\n  x: MAZE_WIDTH_IN_TILES,\n  y: MAZE_HEIGHT_IN_TILES,\n};\n\nexport const isTxValid = (tx: TileCoordinate) =>\n  tx >= 0 && tx < MAZE_WIDTH_IN_TILES;\nexport const isTyValid = (ty: TileCoordinate) =>\n  ty >= 0 && ty < MAZE_HEIGHT_IN_TILES;\nexport const isValidTileCoordinates = (tile: TileCoordinates) =>\n  isTxValid(tile.x) && isTyValid(tile.y);\n\nexport const assertValidTx = (tx: TileCoordinate) => {\n  assert(isTxValid(tx), `Invalid t.x ${tx} width: ${MAZE_WIDTH_IN_TILES}`);\n};\n\nexport const assertValidTy = (ty: TileCoordinate) => {\n  assert(isTyValid(ty), `Invalid t.y ${ty} height: ${MAZE_HEIGHT_IN_TILES}`);\n};\n\nexport const assertValidTileCoordinates = (tile: TileCoordinates) => {\n  assertValidTx(tile.x);\n  assertValidTy(tile.y);\n};\n\nexport const screenFromTileCoordinate = (\n  tileCoordinate: TileCoordinate\n): ScreenCoordinate => tileCoordinate * SCREEN_TILE_SIZE;\n\nexport const tileFromScreenCoordinate = (\n  screenCoordinate: ScreenCoordinate\n): TileCoordinate => Math.floor(screenCoordinate / SCREEN_TILE_SIZE);\n\nexport const screenFromTile = (tile: TileCoordinates): ScreenCoordinates => ({\n  x: screenFromTileCoordinate(tile.x),\n  y: screenFromTileCoordinate(tile.y),\n});\n\nexport const tileFromScreen = (screen: ScreenCoordinates): TileCoordinates => ({\n  x: tileFromScreenCoordinate(screen.x),\n  y: tileFromScreenCoordinate(screen.y),\n});\n\nexport const getPointDifferenceAsVector = (\n  from: Coordinates,\n  to: Coordinates\n): Vector => ({\n  x: to.x - from.x,\n  y: to.y - from.y,\n});\n\nexport const addCoordinatesAndVector = (\n  coordinates: Coordinates,\n  vector: Vector\n): ScreenCoordinates => ({\n  x: coordinates.x + vector.x,\n  y: coordinates.y + vector.y,\n});\n\nexport const rectangleContainsTile = (\n  tileRectangle: TileRectangle,\n  tile: TileCoordinates\n): boolean =>\n  tile.x >= tileRectangle.tile1.x &&\n  tile.x <= tileRectangle.tile2.x &&\n  tile.y >= tileRectangle.tile1.y &&\n  tile.y <= tileRectangle.tile2.y;\n\nexport const wrapTileToBounds = (\n  tile: TileCoordinates,\n  bounds: TileCoordinates\n): TileCoordinates => {\n  const wrappedX = (tile.x + bounds.x) % bounds.x;\n  const wrappedY = (tile.y + bounds.y) % bounds.y;\n  return { x: wrappedX, y: wrappedY };\n};\n","import { collide } from './collisionDetection';\nimport {\n  SCALE_FACTOR,\n  ScreenCoordinates,\n  screenFromTile,\n  TileCoordinates,\n} from './Coordinates';\nimport { eatEnergizer } from './eatEnergizer';\nimport { Game } from './Game';\nimport { Ghost } from './Ghost';\nimport { BASIC_PILL_ID, EMPTY_TILE_ID, ENERGIZER_ID, TileId } from './MazeData';\nimport { Rectangle } from './Rectangle';\n\nconst PILL_BOX_HIT_BOX_WIDTH = 2;\nconst PILL_BOX_HIT_BOX_HEIGHT = 2;\n\nexport const getPillHitBox = (\n  tile: TileCoordinates,\n  pill: TileId\n): Rectangle => {\n  const screen = screenFromTile(tile);\n  return {\n    x: screen.x - PILL_BOX_HIT_BOX_WIDTH / 2,\n    y: screen.y - PILL_BOX_HIT_BOX_WIDTH / 2,\n    width: PILL_BOX_HIT_BOX_WIDTH,\n    height: PILL_BOX_HIT_BOX_HEIGHT,\n  };\n};\n\nconst PAC_MAN_HIT_BOX_WIDTH = 15;\nconst PAC_MAN_HIT_BOX_HEIGHT = 15;\n\nexport const getPacManHitBox = (screen: ScreenCoordinates): Rectangle => {\n  return {\n    x: screen.x - PAC_MAN_HIT_BOX_WIDTH / 2 + 1,\n    y: screen.y - PAC_MAN_HIT_BOX_HEIGHT / 2 + 2,\n    width: PAC_MAN_HIT_BOX_WIDTH,\n    height: PAC_MAN_HIT_BOX_HEIGHT,\n  };\n};\n\nconst GHOST_HIT_BOX_WIDTH = 10;\nconst GHOST_HIT_BOX_HEIGHT = 10;\n\nexport const getGhostHitBox = (screen: ScreenCoordinates): Rectangle => {\n  return {\n    x: screen.x - (GHOST_HIT_BOX_WIDTH * SCALE_FACTOR) / 2,\n    y: screen.y - (GHOST_HIT_BOX_HEIGHT * SCALE_FACTOR) / 2,\n    width: GHOST_HIT_BOX_WIDTH * SCALE_FACTOR,\n    height: GHOST_HIT_BOX_HEIGHT * SCALE_FACTOR,\n  };\n};\n\nconst detectPacManEatingPill = (game: Game) => {\n  const pillTile = game.pacMan.tileCoordinates;\n  const pill: TileId = game.maze.pills[pillTile.y][pillTile.x];\n  if (pill === EMPTY_TILE_ID) {\n    return;\n  }\n\n  const pillHitBox: Rectangle = getPillHitBox(pillTile, pill);\n  const pacManHitBox: Rectangle = getPacManHitBox(\n    game.pacMan.screenCoordinates\n  );\n  if (collide(pacManHitBox, pillHitBox)) {\n    eatPillLayerObject(pillTile, game);\n  }\n};\n\nexport const BASIC_PILL_POINTS = 10;\n\nconst eatPillLayerObject = (tile: TileCoordinates, game: Game) => {\n  const tileId = game.maze.pills[tile.y][tile.x];\n  switch (tileId) {\n    case BASIC_PILL_ID:\n      eatPill(tile, game);\n      break;\n    case ENERGIZER_ID:\n      eatEnergizer(game);\n      break;\n    default:\n      console.error('Unknown pill layer tile id', tileId);\n      break;\n  }\n\n  game.maze.pills[tile.y][tile.x] = EMPTY_TILE_ID;\n};\n\nconst eatPill = (tile: TileCoordinates, game: Game) => {\n  game.score += BASIC_PILL_POINTS;\n};\n\nconst detectGhostCollisions = (game: Game) => {\n  const pacManHitBox: Rectangle = getPacManHitBox(\n    game.pacMan.screenCoordinates\n  );\n\n  for (const ghost of game.ghosts) {\n    if (ghost.dead) {\n      continue;\n    }\n\n    const ghostHitBox: Rectangle = getGhostHitBox(ghost.screenCoordinates);\n    if (collide(pacManHitBox, ghostHitBox)) {\n      ghostCollidesWithPacMan(ghost);\n    }\n  }\n};\n\nexport const ghostCollidesWithPacMan = (ghost: Ghost) => {\n  const game = ghost.game;\n  game.pacMan.send('COLLISION_WITH_GHOST');\n  ghost.send('COLLISION_WITH_PAC_MAN');\n};\n\nexport const detectCollisions = (game: Game) => {\n  if (game.pacMan.dead) {\n    return;\n  }\n\n  detectPacManEatingPill(game);\n  detectGhostCollisions(game);\n};\n","import { assert } from '../util/assert';\n\nexport type PixelsPerFrame = number;\n\nexport type Direction = 'UP' | 'DOWN' | 'RIGHT' | 'LEFT';\n\nexport const Directions: Direction[] = ['UP', 'DOWN', 'LEFT', 'RIGHT'];\n\nexport type MilliSeconds = number;\n\nexport const assertValidDirection = (direction: Direction) => {\n  assert(Directions.includes(direction), `Bad direction ${direction}`);\n};\n","export interface Vector {\n  x: number;\n  y: number;\n}\n\nexport const rotateVectorBy180Degrees = (vector: Vector): Vector =>\n  multiplyVector(-1, vector);\n\nexport const multiplyVector = (factor: number, vector: Vector): Vector => ({\n  x: factor * vector.x,\n  y: factor * vector.y,\n});\n\nexport const divideVector = (vector: Vector, divisor: number): Vector =>\n  multiplyVector(1 / divisor, vector);\n","import { Direction, assertValidDirection } from './Types';\nimport {\n  assertValidTileCoordinates,\n  ScreenCoordinates,\n  TileCoordinates,\n  SCREEN_TILE_SIZE,\n  rectangleContainsTile,\n  TileRectangle,\n  wrapTileToBounds,\n  MAZE_DIMENSIONS_IN_TILES,\n  addCoordinatesAndVector,\n} from './Coordinates';\nimport { waysMatrix, WAY_FREE_ID, BOX_DOOR_ID } from './MazeData';\nimport { Vector, multiplyVector } from './Vector';\n\nconst BOX_TILE_COORDINATES: TileRectangle = {\n  tile1: { x: 10, y: 12 },\n  tile2: { x: 17, y: 16 },\n};\n\nconst BOX_SPACE_TILE_COORDINATES: TileRectangle = {\n  tile1: { x: 12, y: 14 },\n  tile2: { x: 15, y: 14 },\n};\n\nexport const isWayFreeAt = (tile: TileCoordinates): boolean => {\n  assertValidTileCoordinates(tile);\n  return waysMatrix[tile.y][tile.x] === WAY_FREE_ID;\n};\n\nexport const isBoxDoorAt = (tile: TileCoordinates): boolean => {\n  assertValidTileCoordinates(tile);\n  return waysMatrix[tile.y][tile.x] === BOX_DOOR_ID;\n};\n\nexport const isTileInBox = (tile: TileCoordinates): boolean =>\n  rectangleContainsTile(BOX_TILE_COORDINATES, tile);\n\nexport const isTileInBoxSpace = (tile: TileCoordinates): boolean =>\n  rectangleContainsTile(BOX_SPACE_TILE_COORDINATES, tile);\n\nexport const isTileCenter = (screen: ScreenCoordinates): boolean => {\n  return screen.x % SCREEN_TILE_SIZE === 0 && screen.y % SCREEN_TILE_SIZE === 0;\n};\n\nexport const DIRECTION_TO_VECTOR: Record<Direction, Vector> = {\n  RIGHT: { x: 1, y: 0 },\n  LEFT: { x: -1, y: 0 },\n  UP: { x: 0, y: -1 },\n  DOWN: { x: 0, y: 1 },\n};\n\nexport const directionToVector = (direction: Direction, distance = 1): Vector =>\n  multiplyVector(distance, DIRECTION_TO_VECTOR[direction]);\n\nexport const moveFromTile = (\n  tile: TileCoordinates,\n  direction: Direction,\n  steps = 1\n) => {\n  const step = DIRECTION_TO_VECTOR[direction];\n  const newTile = { x: tile.x + step.x * steps, y: tile.y + step.y * steps };\n  return newTile;\n};\n\nexport const DIRECTION_TO_OPPOSITE_DIRECTION: Record<Direction, Direction> = {\n  RIGHT: 'LEFT',\n  LEFT: 'RIGHT',\n  UP: 'DOWN',\n  DOWN: 'UP',\n};\n\nexport const isOppositeDirection = (\n  direction1: Direction,\n  direction2: Direction\n) => {\n  return DIRECTION_TO_OPPOSITE_DIRECTION[direction1] === direction2;\n};\n\nexport const isWayFreeInDirection = (\n  tile: TileCoordinates,\n  direction: Direction,\n  stepSize = 1\n): boolean => {\n  const nextTile = getNextTile(tile, direction, stepSize);\n  return isWayFreeAt(nextTile);\n};\n\nexport const getNextTile = (\n  tile: TileCoordinates,\n  direction: Direction,\n  stepSize = 1\n): TileCoordinates => {\n  assertValidDirection(direction);\n  const vector: Vector = DIRECTION_TO_TILE_VECTOR[direction];\n  const scaledVector = multiplyVector(stepSize, vector);\n  const movedTile = addCoordinatesAndVector(tile, scaledVector);\n  const nextTile = wrapTileToBounds(movedTile, MAZE_DIMENSIONS_IN_TILES);\n  return nextTile;\n};\n\nconst DIRECTION_TO_TILE_VECTOR = {\n  RIGHT: { x: 1, y: 0 },\n  LEFT: { x: -1, y: 0 },\n  UP: { x: 0, y: -1 },\n  DOWN: { x: 0, y: 1 },\n};\n","import { TileCoordinates } from './Coordinates';\n\nexport const getTileDistance = (\n  neighbourTile: TileCoordinates,\n  targetTile: TileCoordinates\n) => {\n  const dx = Math.abs(neighbourTile.x - targetTile.x);\n  const dy = Math.abs(neighbourTile.y - targetTile.y);\n  return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n};\n","import {\n  TileCoordinates,\n  getPointDifferenceAsVector,\n  addCoordinatesAndVector,\n} from './Coordinates';\nimport { Ghost } from './Ghost';\nimport { moveFromTile, isWayFreeInDirection, getNextTile } from './Ways';\nimport { getTileDistance } from './getTileDistance';\nimport { Directions, Direction } from './Types';\nimport { rotateVectorBy180Degrees } from './Vector';\nimport { assert } from '../util/assert';\n\nexport const TILE_FOR_LEAVING_THE_BOX: TileCoordinates = {\n  x: 13,\n  y: 11,\n};\n\nexport const TILE_FOR_RETURNING_TO_BOX: TileCoordinates = {\n  x: 14,\n  y: 14,\n};\n\nexport const SCATTER_TILE_FOR_GHOST_0: TileCoordinates = { x: 26, y: 1 };\n\nexport const chooseNewTargetTile = (ghost: Ghost): TileCoordinates => {\n  switch (ghost.state) {\n    case 'scatter':\n      return chooseInScatterMode(ghost);\n    case 'chase':\n      return choseInChaseMode(ghost);\n    case 'frightened':\n      return chooseInFrightenedMode(ghost);\n    case 'dead':\n      return chooseInDeadMode(ghost);\n    default:\n      throw new Error(`Bad state ${ghost.state}`);\n  }\n};\n\nconst chooseInScatterMode = (ghost: Ghost): TileCoordinates => {\n  if (ghost.isInsideBoxWalls) {\n    return TILE_FOR_LEAVING_THE_BOX;\n  }\n  switch (ghost.ghostNumber) {\n    case 0:\n      return SCATTER_TILE_FOR_GHOST_0;\n    case 1:\n      return { x: 1, y: 1 };\n    case 2:\n      return { x: 26, y: 29 };\n    case 3:\n      return { x: 1, y: 29 };\n    default:\n      throw new Error(`Bad ghostNumber ${ghost.ghostNumber}`);\n  }\n};\n\nconst chooseForGhost0InChaseState = (ghost: Ghost): TileCoordinates => {\n  const pacMan = ghost.game.pacMan;\n  return pacMan.tileCoordinates;\n};\n\nconst chooseForGhost1InChaseState = (ghost: Ghost): TileCoordinates => {\n  const pacMan = ghost.game.pacMan;\n  const fourTilesAhead = moveFromTile(\n    pacMan.tileCoordinates,\n    pacMan.direction,\n    4\n  );\n  return pacMan.direction === 'UP'\n    ? moveFromTile(fourTilesAhead, 'LEFT', 4)\n    : fourTilesAhead;\n};\n\nconst chooseForGhost2InChaseState = (ghost: Ghost): TileCoordinates => {\n  const intermediateTile = chooseGhost2IntermediateTile(ghost);\n  const blinky = ghost.game.ghosts[0];\n  const vectorToBlinky = getPointDifferenceAsVector(\n    intermediateTile,\n    blinky.tileCoordinates\n  );\n  const rotatedVector = rotateVectorBy180Degrees(vectorToBlinky);\n  const newTile = addCoordinatesAndVector(intermediateTile, rotatedVector);\n\n  return newTile;\n};\n\nexport const chooseGhost2IntermediateTile = (ghost: Ghost): TileCoordinates => {\n  const pacMan = ghost.game.pacMan;\n  const twoTilesAhead = moveFromTile(\n    pacMan.tileCoordinates,\n    pacMan.direction,\n    2\n  );\n  return pacMan.direction === 'UP'\n    ? moveFromTile(twoTilesAhead, 'LEFT', 2)\n    : twoTilesAhead;\n};\n\nconst chooseForGhost3InChaseState = (ghost: Ghost): TileCoordinates => {\n  const pacMan = ghost.game.pacMan;\n  const distance = getTileDistance(\n    ghost.tileCoordinates,\n    pacMan.tileCoordinates\n  );\n\n  return distance >= 8 ? pacMan.tileCoordinates : chooseInScatterMode(ghost);\n};\n\nconst choseInChaseMode = (ghost: Ghost): TileCoordinates => {\n  if (ghost.isInsideBoxWalls) {\n    return TILE_FOR_LEAVING_THE_BOX;\n  }\n  switch (ghost.ghostNumber) {\n    case 0:\n      return chooseForGhost0InChaseState(ghost);\n    case 1:\n      return chooseForGhost1InChaseState(ghost);\n    case 2:\n      return chooseForGhost2InChaseState(ghost);\n    case 3:\n      return chooseForGhost3InChaseState(ghost);\n    default:\n      throw new Error(`Bad ghostNumber ${ghost.ghostNumber}`);\n  }\n};\n\nconst getRandomInt = (max: number) =>\n  Math.floor(Math.random() * Math.floor(max));\n\nconst chooseInFrightenedMode = (ghost: Ghost): TileCoordinates => {\n  // Choose a random neighbour tile that is not backward and not into a wall.\n\n  return chooseSomeRandomMovement(ghost);\n};\n\n/**\n * Choose a random neighbour tile that is not backward and not into a wall.\n */\nconst chooseSomeRandomMovement = (ghost: Ghost): TileCoordinates => {\n  const candidateDirections: Direction[] = Directions.filter(\n    direction =>\n      direction !== ghost.direction &&\n      isWayFreeInDirection(ghost.tileCoordinates, direction)\n  );\n  assert(candidateDirections.length > 0);\n  const newDirection =\n    candidateDirections[getRandomInt(candidateDirections.length)];\n  assert(newDirection);\n  const randomNeighourTile = getNextTile(ghost.tileCoordinates, newDirection);\n\n  return randomNeighourTile;\n};\n\nconst chooseInDeadMode = (ghost: Ghost): TileCoordinates => {\n  // if (ghost.deadWaitingTimeInBoxLeft < 0) {\n  //   return chooseSomeRandomMovement(ghost);\n  // }\n  return TILE_FOR_RETURNING_TO_BOX;\n};\n","import { minBy } from 'lodash';\nimport { isValidTileCoordinates, TileCoordinates } from './Coordinates';\nimport { Direction, Directions } from './Types';\nimport {\n  getNextTile,\n  isOppositeDirection,\n  isWayFreeAt,\n  isBoxDoorAt,\n} from './Ways';\nimport { getTileDistance } from './getTileDistance';\nimport { toJS } from 'mobx';\nimport { assert } from '../util/assert';\n\ninterface CandidateTile {\n  tile: TileCoordinates;\n  distanceToTarget: number;\n}\n\nexport const chooseNextTile = ({\n  currentTile,\n  currentDirection,\n  targetTile,\n  boxDoorIsOpen,\n}: {\n  currentTile: TileCoordinates;\n  currentDirection: Direction;\n  targetTile: TileCoordinates;\n  boxDoorIsOpen: boolean;\n}): TileCoordinates => {\n  assert(isValidTileCoordinates(currentTile), `${toJS(currentTile)}`);\n  const bestNextTile = chooseBestNextTile({\n    currentTile,\n    currentDirection,\n    targetTile,\n    boxDoorIsOpen,\n  });\n\n  if (bestNextTile) {\n    assert(isValidTileCoordinates(bestNextTile));\n    return bestNextTile;\n  }\n\n  const anyNextTile = chooseAnyNextTile({\n    currentTile,\n    currentDirection,\n    boxDoorIsOpen,\n  });\n  if (anyNextTile) {\n    assert(isValidTileCoordinates(anyNextTile));\n    return anyNextTile;\n  }\n\n  console.error('currentTile', currentTile);\n  console.error('currentDirection', currentDirection);\n  console.error('boxDoorIsOpen', boxDoorIsOpen);\n  console.error('targetTile', toJS(targetTile));\n\n  throw new Error(`Found no candidate at ${JSON.stringify(currentTile)}`);\n};\n\nconst chooseBestNextTile = ({\n  currentTile,\n  currentDirection,\n  targetTile,\n  boxDoorIsOpen,\n}: {\n  currentTile: TileCoordinates;\n  currentDirection: Direction;\n  targetTile: TileCoordinates;\n  boxDoorIsOpen: boolean;\n}): TileCoordinates | null => {\n  const candidates = [] as CandidateTile[];\n  for (const direction of Directions) {\n    // Prevent the ghost from going backwards\n    if (isOppositeDirection(direction, currentDirection)) {\n      continue;\n    }\n    const neighbourTile = getNextTile(currentTile, direction);\n\n    if (!possibleNextTile(neighbourTile, boxDoorIsOpen)) {\n      continue;\n    }\n\n    const distanceToTarget = getTileDistance(neighbourTile, targetTile);\n    candidates.push({ tile: neighbourTile, distanceToTarget });\n  }\n\n  const bestCandidate = minBy(candidates, 'distanceToTarget');\n  if (bestCandidate) {\n    return bestCandidate.tile;\n  } else {\n    return null;\n  }\n};\n\nconst chooseAnyNextTile = ({\n  currentTile,\n  currentDirection,\n  boxDoorIsOpen,\n}: {\n  currentTile: TileCoordinates;\n  currentDirection: Direction;\n  boxDoorIsOpen: boolean;\n}): TileCoordinates | null => {\n  // Prioritize the current direction\n  const neighbourTileInCurrentDirection = getNextTile(\n    currentTile,\n    currentDirection\n  );\n\n  if (possibleNextTile(neighbourTileInCurrentDirection, boxDoorIsOpen)) {\n    return neighbourTileInCurrentDirection;\n  }\n\n  // Choose any possible next tile\n  for (const direction of Directions) {\n    const neighbourTile = getNextTile(currentTile, direction);\n    if (possibleNextTile(neighbourTile, boxDoorIsOpen)) {\n      return neighbourTile;\n    }\n  }\n\n  return null;\n};\n\nconst possibleNextTile = (\n  tileCoordinates: TileCoordinates,\n  boxDoorIsOpen: boolean\n): boolean => {\n  return (\n    isValidTileCoordinates(tileCoordinates) &&\n    isWayFreeForGhostAt(tileCoordinates, boxDoorIsOpen)\n  );\n};\n\nconst isWayFreeForGhostAt = (\n  tileCoordinates: TileCoordinates,\n  boxDoorIsOpen: boolean\n): boolean =>\n  isWayFreeAt(tileCoordinates) ||\n  (boxDoorIsOpen && isBoxDoorAt(tileCoordinates));\n","import { TileCoordinates, TileCoordinate } from './Coordinates';\nimport { isEqual } from 'lodash';\nimport { assert } from '../util/assert';\nimport { Direction } from './Types';\nimport { MAZE_WIDTH_IN_TILES } from './MazeData';\n\nconst TUNNEL_X_LEFT: TileCoordinate = 0;\nconst TUNNEL_X_RIGHT: TileCoordinate = MAZE_WIDTH_IN_TILES - 1;\n\nexport const getDirectionFromTileToTile = (\n  tileFrom: TileCoordinates,\n  tileTo: TileCoordinates\n): Direction => {\n  assert(tileFrom, 'tileFrom');\n  assert(tileTo, 'tileTo');\n\n  if (isEqual(tileFrom, tileTo)) {\n    throw new Error('Same tile');\n  }\n\n  // Go through the tunnel?\n  if (tileFrom.x === TUNNEL_X_RIGHT && tileTo.x === TUNNEL_X_LEFT) {\n    return 'RIGHT';\n  }\n  // Go through the tunnel?\n  if (tileFrom.x === TUNNEL_X_LEFT && tileTo.x === TUNNEL_X_RIGHT) {\n    return 'LEFT';\n  }\n  if (tileFrom.x < tileTo.x) {\n    return 'RIGHT';\n  }\n  if (tileFrom.x > tileTo.x) {\n    return 'LEFT';\n  }\n  if (tileFrom.y < tileTo.y) {\n    return 'DOWN';\n  }\n  if (tileFrom.y > tileTo.y) {\n    return 'UP';\n  }\n  throw new Error('Same tiles');\n};\n","import { action } from 'mobx';\nimport { Ghost } from './Ghost';\nimport { MilliSeconds } from './Types';\nimport { StateValue } from 'xstate';\n\nexport const CHASE_PHASE_LENGTH = 20 * 1000;\nexport const SCATTER_PHASE_LENGTH = 7 * 1000;\n\nexport const updateGhostStatePhaseTime = action(\n  'updateGhostStatePhaseTime',\n  (ghost: Ghost) => {\n    ghost.statePhaseTimer.advance(ghost.game.lastFrameLength);\n  }\n);\n\nexport const updateGhostStatePhase = action(\n  'updateGhostStatePhase',\n  (ghost: Ghost) => {\n    if (!ghost.atTileCenter) {\n      return;\n    }\n\n    if (ghost.statePhaseTimer.isTimedOut) {\n      ghost.send('PHASE_END');\n      ghost.statePhaseTimer.setDuration(getStatePhaseLength(ghost.state));\n      ghost.statePhaseTimer.restart();\n    }\n  }\n);\n\nexport const getStatePhaseLength = (state: StateValue): MilliSeconds => {\n  switch (state) {\n    case 'chase':\n      return CHASE_PHASE_LENGTH;\n    case 'scatter':\n      return SCATTER_PHASE_LENGTH;\n    default:\n      // Never ends\n      return 9999999999;\n  }\n};\n","import { chooseNewTargetTile } from './chooseNewTargetTile';\nimport { chooseNextTile } from './chooseNextTile';\nimport {\n  TileCoordinates,\n  MAZE_WIDTH_IN_SCREEN_COORDINATES,\n  MAZE_HEIGHT_IN_SCREEN_COORDINATES,\n  assertValidTileCoordinates,\n} from './Coordinates';\nimport { getDirectionFromTileToTile } from './getDirectionFromTileToTile';\nimport { Ghost } from './Ghost';\nimport { Direction } from './Types';\nimport { directionToVector } from './Ways';\nimport {\n  updateGhostStatePhaseTime,\n  updateGhostStatePhase,\n} from './updateGhostStatePhase';\nimport { Vector } from './Vector';\nimport { Game } from './Game';\nimport { action } from 'mobx';\n\nexport const updateGhosts = (game: Game) => {\n  for (const ghost of game.ghosts) {\n    updateGhost({ ghost });\n  }\n};\n\nconst updateGhost = ({ ghost }: { ghost: Ghost }) => {\n  if (ghost.ghostPaused) {\n    return;\n  }\n\n  updateGhostStatePhaseTime(ghost);\n  updateDeadWaitingTimeInBoxLeft(ghost);\n\n  updateGhostStatePhase(ghost);\n\n  routeAndMoveGhost(ghost);\n};\n\nconst updateDeadWaitingTimeInBoxLeft = (ghost: Ghost) => {\n  if (ghost.dead && ghost.deadWaitingTimeInBoxLeft > 0) {\n    ghost.deadWaitingTimeInBoxLeft -= ghost.game.lastFrameLength;\n  }\n};\n\nexport const routeAndMoveGhost = (ghost: Ghost) => {\n  if (ghost.game.pacMan.dead) {\n    return;\n  }\n\n  if (ghost.atTileCenter) {\n    reRouteGhost(ghost);\n  }\n\n  moveGhost(ghost);\n};\n\nconst reRouteGhost = (ghost: Ghost) => {\n  ghost.targetTile = chooseNewTargetTile(ghost);\n  updateDirection(ghost);\n  updateSpeed(ghost);\n};\n\nconst updateDirection = (ghost: Ghost) => {\n  const newDirection = getNewDirection(ghost);\n  ghost.direction = newDirection;\n};\n\nconst updateSpeed = (ghost: Ghost) => {\n  const newSpeedFactor = getNewSpeedFactor(ghost);\n  ghost.speedFactor = newSpeedFactor;\n};\n\nexport const getNewDirection = (ghost: Ghost): Direction => {\n  const currentTile = ghost.tileCoordinates;\n  const currentDirection = ghost.direction;\n  const targetTile = ghost.targetTile;\n  const boxDoorIsOpen = ghost.canPassThroughBoxDoor;\n\n  const nextTile: TileCoordinates = chooseNextTile({\n    currentTile,\n    currentDirection,\n    targetTile,\n    boxDoorIsOpen,\n  });\n\n  return getDirectionFromTileToTile(currentTile, nextTile);\n};\n\nconst moveGhost = (ghost: Ghost) => {\n  const vector: Vector = getGhostMovementVector(ghost);\n  moveGhostBy(ghost, vector);\n};\n\nconst moveGhostBy = action((ghost: Ghost, vector: Vector) => {\n  ghost.screenCoordinates.x =\n    (ghost.screenCoordinates.x + vector.x + MAZE_WIDTH_IN_SCREEN_COORDINATES) %\n    MAZE_WIDTH_IN_SCREEN_COORDINATES;\n  ghost.screenCoordinates.y =\n    (ghost.screenCoordinates.y + vector.y + MAZE_HEIGHT_IN_SCREEN_COORDINATES) %\n    MAZE_HEIGHT_IN_SCREEN_COORDINATES;\n\n  assertValidTileCoordinates(ghost.tileCoordinates);\n});\n\nconst isInTunnel = (tile: TileCoordinates) =>\n  tile.y === 14 && (tile.x >= 22 || tile.x <= 5);\n\nconst getGhostMovementVector = (ghost: Ghost): Vector => {\n  const speed = ghost.game.speed * ghost.speedFactor;\n  const velocity = directionToVector(ghost.direction, speed);\n  return velocity;\n};\n\nexport const SPEED_FACTOR_HIGH = 2;\nexport const SPEED_FACTOR_NORMAL = 1;\nexport const SPEED_FACTOR_SLOW = 0.5;\n\nconst getNewSpeedFactor = (ghost: Ghost): number => {\n  if (ghost.dead) {\n    return SPEED_FACTOR_HIGH;\n  }\n  if (isInTunnel(ghost.tileCoordinates) || ghost.state === 'frightened') {\n    return SPEED_FACTOR_SLOW;\n  }\n  return SPEED_FACTOR_NORMAL;\n};\n","/* eslint-disable react/display-name */\nimport { Button, Row, Switch, Table } from 'antd';\nimport { ColumnsType } from 'antd/lib/table';\nimport { action } from 'mobx';\nimport { observer, Observer } from 'mobx-react-lite';\nimport React, { FC } from 'react';\nimport styled from 'styled-components';\nimport { ghostCollidesWithPacMan } from '../../../model/detectCollisions';\nimport { Ghost } from '../../../model/Ghost';\nimport { routeAndMoveGhost } from '../../../model/updateGhosts';\nimport { useGame } from '../../../components/StoreContext';\n\nconst columns: ColumnsType<Ghost> = [\n  {\n    title: 'Nr',\n    dataIndex: 'ghostNumber',\n    width: 50,\n    align: 'center',\n  },\n  {\n    title: 'Name',\n    width: 80,\n    render: (ghost: Ghost) => (\n      <Row align=\"middle\">\n        <Dot color={ghost.colorCode} size={7} />\n        &nbsp;&nbsp;\n        {ghost.name}\n      </Row>\n    ),\n  },\n  {\n    title: 'State',\n    width: 80,\n    align: 'center',\n    render: ghost => <Observer>{() => ghost.state.toString()}</Observer>,\n  },\n  {\n    title: '# Changes',\n    width: 80,\n    align: 'right',\n    render: ghost => <Observer>{() => ghost.stateChanges.toString()}</Observer>,\n  },\n  {\n    title: 'X',\n    width: 32,\n    align: 'right',\n    render: ghost => <Observer>{(): any => ghost.tileCoordinates.x}</Observer>,\n  },\n  {\n    title: 'Y',\n    width: 32,\n    align: 'right',\n    render: ghost => <Observer>{(): any => ghost.tileCoordinates.y}</Observer>,\n  },\n  {\n    title: 'Paused',\n    align: 'center',\n    render: ghost => <PausedSwitch ghost={ghost} />,\n  },\n  {\n    title: '',\n    align: 'center',\n    width: 60,\n    render: ghost => <KillButton ghost={ghost} />,\n  },\n  {\n    title: '',\n    align: 'center',\n    width: 60,\n    render: record => <MoveButton ghost={record} />,\n  },\n  {\n    title: '',\n    render: record => null,\n  },\n];\n\nconst PausedSwitch: FC<{ ghost: Ghost }> = observer(({ ghost }) => (\n  <Switch\n    checked={ghost.ghostPaused}\n    onChange={checked => {\n      ghost.ghostPaused = checked;\n    }}\n  />\n));\n\nconst KillButton = observer<{ ghost: Ghost }>(({ ghost }) => (\n  <Button\n    size=\"small\"\n    shape=\"round\"\n    disabled={!ghost.frightened}\n    onClick={() => {\n      ghostCollidesWithPacMan(ghost);\n    }}\n  >\n    Kill\n  </Button>\n));\n\nconst MoveButton = observer<{ ghost: Ghost }>(({ ghost }) => (\n  <Button\n    size=\"small\"\n    shape=\"round\"\n    onClick={action(() => {\n      routeAndMoveGhost(ghost);\n    })}\n  >\n    Move\n  </Button>\n));\n\nexport const GhostsDebugTable = observer<{ className?: string }>(\n  ({ className }) => {\n    const store = useGame();\n    return (\n      <Table\n        className={className}\n        dataSource={store.ghosts}\n        columns={columns}\n        pagination={false}\n        size=\"small\"\n        rowKey=\"ghostNumber\"\n      />\n    );\n  }\n);\n\ninterface DotProps {\n  color: string;\n  size: number;\n}\n\nconst Dot = styled.div<DotProps>`\n  border-radius: ${({ size }) => size}px;\n  width: ${({ size }) => size}px;\n  height: ${({ size }) => size}px;\n  background-color: ${({ color }) => color};\n  display: inline-block;\n`;\n","import styled from 'styled-components/macro';\n\nconst DEFAULT_SIZE = '8px';\n\nconst SIZE_MAPPING: { [key: string]: string } = {\n  small: '8px',\n  medium: '16px',\n  large: '24px',\n};\n\ntype Size = 'small' | 'middle' | 'large' | string;\nconst mappedSize = (size: Size): string => SIZE_MAPPING[size] ?? size;\n\nexport const HSpace = styled.div<{ size?: Size }>`\n  width: ${({ size = DEFAULT_SIZE }) => mappedSize(size)};\n`;\n\nexport const VSpace = styled.div<{ size?: Size }>`\n  height: ${({ size = DEFAULT_SIZE }) => mappedSize(size)};\n`;\n","import { Card } from 'antd';\nimport { observer } from 'mobx-react-lite';\nimport React, { FC } from 'react';\nimport { GhostDebugControls } from './GhostDebugControls';\nimport { GhostsDebugTable } from './GhostDebugTable';\nimport { VSpace } from '../../../components/Spacer';\n\nexport const GhostsDebugView: FC = observer(() => {\n  return (\n    <div className=\"GhostsDebugView\">\n      <Card title=\"Ghosts\" size=\"small\" bordered={false}>\n        <VSpace size=\"small\" />\n        <GhostsDebugTable />\n        <VSpace size=\"32px\" />\n        <GhostDebugControls />\n      </Card>\n    </div>\n  );\n});\n","import { Button, Card, Space, Row, Col } from 'antd';\nimport { observer } from 'mobx-react-lite';\nimport React from 'react';\nimport styled from 'styled-components/macro';\nimport { ghostCollidesWithPacMan } from '../../../model/detectCollisions';\nimport { useGame } from '../../../components/StoreContext';\n\nexport const PacManDebugView = observer<{ className?: string }>(\n  ({ className }) => {\n    const game = useGame();\n    return (\n      <Layout className=\"PacManDebugView\">\n        <Card title=\"Pac Man\" size=\"small\" bordered={false}>\n          <Row>\n            <Col flex=\"0 0 104px\">State: {game.pacMan.state}</Col>\n\n            <Col flex=\"0 0 48px\"></Col>\n\n            <Col flex=\"0 0 auto\">\n              <Space>\n                {game.pacMan.alive && (\n                  <ButtonStyled\n                    shape=\"round\"\n                    size=\"small\"\n                    onClick={() => {\n                      ghostCollidesWithPacMan(game.ghosts[0]);\n                    }}\n                  >\n                    Kill\n                  </ButtonStyled>\n                )}\n                {game.pacMan.dead && (\n                  <ButtonStyled\n                    shape=\"round\"\n                    size=\"small\"\n                    onClick={game.revivePacMan}\n                  >\n                    Revive\n                  </ButtonStyled>\n                )}\n              </Space>\n            </Col>\n          </Row>\n        </Card>\n      </Layout>\n    );\n  }\n);\n\nconst Layout = styled.div``;\n\nconst ButtonStyled = styled(Button)`\n  min-width: 80px;\n`;\n","/* eslint-disable react/display-name */\nimport { Button, Card, Col, Row, Switch, Typography } from 'antd';\nimport { observer } from 'mobx-react-lite';\nimport React from 'react';\nimport styled from 'styled-components/macro';\nimport { useGame, useStore } from '../../../components/StoreContext';\nimport { action } from 'mobx';\n\nconst { Text } = Typography;\n\nexport const GameDebugView = observer<{ className?: string }>(\n  ({ className }) => {\n    const store = useStore();\n    const game = useGame();\n    return (\n      <Layout className=\"PacManDebugView\">\n        <Card title=\"Game\" size=\"small\" bordered={false}>\n          <Row>\n            <Col flex=\"0 0 56px\">\n              <Switch\n                checked={store.debugState.gameViewOptions.hitBox}\n                onChange={action(\n                  checked => (store.debugState.gameViewOptions.hitBox = checked)\n                )}\n              />\n            </Col>\n            <Col flex=\"0 0 auto\">\n              <Text>Show Hit Boxes</Text>\n            </Col>\n            <Col flex=\"0 0 48px\"></Col>\n\n            <Col flex=\"0 0 56px\">\n              <Switch\n                checked={game.gamePaused}\n                onChange={checked => {\n                  game.gamePaused = checked;\n                }}\n              />\n            </Col>\n            <Col flex=\"0 0 auto\">\n              <Text>Paused</Text>\n            </Col>\n            <Col flex=\"0 0 48px\"></Col>\n\n            <ButtonStyled size=\"small\" onClick={store.resetGame} shape=\"round\">\n              Restart\n            </ButtonStyled>\n          </Row>\n        </Card>\n      </Layout>\n    );\n  }\n);\n\nconst Layout = styled.div``;\n\nconst ButtonStyled = styled(Button)`\n  min-width: 80px;\n`;\n","import { Card, Space } from 'antd';\nimport React, { FC } from 'react';\nimport styled from 'styled-components/macro';\nimport { EnergizerDebugView } from './EnergizerDebugView';\nimport { GhostsDebugView } from './GhostsDebugView';\nimport { PacManDebugView } from './PacManDebugView';\nimport { GameDebugView } from './GameDebugView';\n\nexport const DebugView: FC<{ className?: string }> = ({ className }) => {\n  return (\n    <Layout className={className}>\n      <CardInline>\n        <Space direction=\"vertical\" size=\"large\">\n          <GameDebugView />\n          <PacManDebugView />\n          <GhostsDebugView />\n          <EnergizerDebugView />\n        </Space>\n      </CardInline>\n    </Layout>\n  );\n};\n\nexport const Layout = styled.div``;\n\nexport const CardInline = styled(Card)`\n  display: inline-block;\n`;\n","import React, { FC, CSSProperties } from 'react';\nimport classNames from 'classnames';\nimport { SCALE_FACTOR } from '../model/Coordinates';\nimport './Sprite.css';\n\nconst scale = `scale(${SCALE_FACTOR})`;\n\nexport const Sprite: FC<{\n  name: string;\n  x: number;\n  y: number;\n  className?: string | null;\n  style?: CSSProperties;\n}> = ({ name: spriteName, x, y, className, style = {} }) => {\n  return (\n    <div\n      className={classNames('Sprite', 'Sprite-' + spriteName, className)}\n      style={{\n        ...style,\n        position: 'absolute',\n        left: `${x}px`,\n        top: `${y}px`,\n        transform: scale,\n        transformOrigin: 'top left',\n      }}\n    />\n  );\n};\n","import React, { FC } from 'react';\nimport { Rectangle } from '../model/Rectangle';\n\nexport const Box: FC<{ rect: Rectangle; color: string }> = ({\n  rect,\n  color,\n}) => (\n  <div\n    style={{\n      position: 'absolute',\n      left: rect.x,\n      top: rect.y,\n      width: rect.width,\n      height: rect.height,\n      backgroundColor: color,\n      zIndex: 1000,\n    }}\n  />\n);\n","import { MilliSeconds } from './Types';\nimport { PacMan } from './PacMan';\n\nexport type PacManDyingPhase = number;\nexport const PacManDyingPhaseCount = 13;\nexport const PacManDyingPhases: PacManDyingPhase[] = Array.from(\n  Array(PacManDyingPhaseCount).keys()\n);\nexport const PacManDyingPhaseLength: MilliSeconds = 200;\nexport const TotalPacManDyingAnimationLength: MilliSeconds =\n  PacManDyingPhaseLength * PacManDyingPhaseCount;\n\nexport const getPacManDyingPhase = (pacMan: PacMan): PacManDyingPhase => {\n  let dyingPhase: number = Math.floor(\n    pacMan.timeSinceDeath / PacManDyingPhaseLength\n  );\n  if (dyingPhase >= PacManDyingPhaseCount) {\n    dyingPhase = PacManDyingPhaseCount - 1;\n  }\n  return dyingPhase as PacManDyingPhase;\n};\n","import React, { FC, CSSProperties } from 'react';\nimport { Sprite } from '../../../components/Sprite';\nimport { Direction } from '../../../model/Types';\nimport { observer } from 'mobx-react-lite';\nimport { useGame, useStore } from '../../../components/StoreContext';\nimport {\n  SCREEN_TILE_SIZE,\n  SCREEN_TILE_CENTER,\n} from '../../../model/Coordinates';\nimport { Box } from '../../../components/Box';\nimport { PacMan } from '../../../model/PacMan';\nimport { getPacManHitBox } from '../../../model/detectCollisions';\nimport {\n  PacManDyingPhase,\n  getPacManDyingPhase,\n} from '../../../model/pacManDyingPhase';\n\nexport type PacManAnimationPhase = 0 | 1 | 2;\n\nexport const PacManAnimationPhases: PacManAnimationPhase[] = [0, 1, 2];\n\nconst PAC_MAN_WIDTH = SCREEN_TILE_SIZE * 2;\nconst PAC_MAN_HEIGHT = SCREEN_TILE_SIZE * 2;\n\nconst PAC_MAN_OFFSET_X = PAC_MAN_WIDTH / 2 - 2;\nconst PAC_MAN_OFFSET_Y = PAC_MAN_HEIGHT / 2 - 2;\n\nexport const PacManView: FC = observer(() => {\n  const store = useStore();\n  const game = useGame();\n  const pacMan = game.pacMan;\n  const { dead, alive, screenCoordinates, direction } = pacMan;\n  const { gameViewOptions } = store.debugState;\n  const pacManAnimationPhase = getPacManAnimationPhase(pacMan);\n  const dyingPhase = getPacManDyingPhase(pacMan);\n  return (\n    <>\n      {gameViewOptions.hitBox && (\n        <PacManHitBox\n          x={screenCoordinates.x + SCREEN_TILE_CENTER}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER}\n        />\n      )}\n      {alive && (\n        <PacManSprite\n          direction={direction}\n          pacManAnimationPhase={pacManAnimationPhase}\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_X}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_Y}\n        />\n      )}\n      {dead && (\n        <DyingPacManSprite\n          dyingPacManAnimationPhase={dyingPhase}\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_X}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_Y}\n        />\n      )}\n    </>\n  );\n});\n\nconst getPacManAnimationPhase = (pacMan: PacMan): PacManAnimationPhase => {\n  const step = Math.round(pacMan.game.timestamp / 200) % 4;\n  const phase = step === 3 ? 1 : step;\n  return phase as PacManAnimationPhase;\n};\n\nexport const PacManSprite: FC<{\n  direction: Direction;\n  pacManAnimationPhase: PacManAnimationPhase;\n  x: number;\n  y: number;\n  style?: CSSProperties;\n}> = ({ direction, pacManAnimationPhase, x, y, style }) => (\n  <Sprite\n    className=\"Sprite-pacman\"\n    name={`pacman-direction-${direction}-phase-${pacManAnimationPhase}`}\n    x={x}\n    y={y}\n    style={style}\n  />\n);\n\nexport const DyingPacManSprite: FC<{\n  dyingPacManAnimationPhase: PacManDyingPhase;\n  x: number;\n  y: number;\n  style?: CSSProperties;\n}> = ({ dyingPacManAnimationPhase, x, y, style }) => (\n  <Sprite\n    className=\"Sprite-dying-pacman\"\n    name={`dying-pacman-phase-${dyingPacManAnimationPhase}`}\n    x={x}\n    y={y}\n    style={style}\n  />\n);\n\nexport const PacManHitBox: FC<{ x: number; y: number }> = ({ x, y }) => {\n  const rect = getPacManHitBox({ x, y });\n  return <Box rect={rect} color=\"green\" />;\n};\n","import { observer } from 'mobx-react-lite';\nimport React from 'react';\nimport { useGame } from '../../../components/StoreContext';\nimport classNames from 'classnames';\nimport styled from 'styled-components/macro';\nimport { PacManSprite } from './PacManView';\nimport { times } from 'lodash';\nimport { SCALE_FACTOR } from '../../../model/Coordinates';\n\nexport const ExtraLives = observer<{ className?: string }>(({ className }) => {\n  const game = useGame();\n  return (\n    <Layout className={classNames('ExtraLives', className)}>\n      <span>\n        {times(game.pacMan.extraLivesLeft, n => (\n          <PacManSprite\n            key={n}\n            direction=\"LEFT\"\n            pacManAnimationPhase={1}\n            x={n * 20 * SCALE_FACTOR}\n            y={0}\n          />\n        ))}\n      </span>\n    </Layout>\n  );\n});\n\nconst Layout = styled.div`\n  display: inline-flex;\n  position: relative;\n  width: calc(1 * 40px * var(--SCALE_FACTOR));\n  height: calc(16px * var(--SCALE_FACTOR));\n`;\n","import { observer } from 'mobx-react-lite';\nimport React from 'react';\nimport styled from 'styled-components/macro';\n\nexport const Message = observer<{ className?: string; text: string }>(\n  ({ className, text }) => {\n    return <MessageStyled className={className}>{text}</MessageStyled>;\n  }\n);\n\nconst MessageStyled = styled.span`\n  font-family: Joystix;\n  font-size: 24px;\n  color: yellow;\n  position: absolute;\n  left: 170px;\n  top: 332px;\n  width: 220px;\n  text-align: center;\n`;\n","import { observer } from 'mobx-react-lite';\nimport React, { FC } from 'react';\nimport './GameOver.css';\nimport { useGame } from '../../../components/StoreContext';\nimport { Message } from './Message';\nimport { TotalPacManDyingAnimationLength } from '../../../model/pacManDyingPhase';\n\nexport const TOTAL_TIME_TO_GAME_OVER_MESSAGE = TotalPacManDyingAnimationLength;\n\nexport const GameOver: FC<{ className?: string }> = observer(\n  ({ className }) => {\n    const game = useGame();\n    const { pacMan } = game;\n    const gameOverMessageVisible =\n      game.gameOver && pacMan.timeSinceDeath >= TOTAL_TIME_TO_GAME_OVER_MESSAGE;\n\n    return gameOverMessageVisible ? <Message text=\"Game Over\" /> : null;\n  }\n);\n","import React from 'react';\nimport { ScreenCoordinates, SCREEN_TILE_SIZE } from '../../model/Coordinates';\nimport styled from 'styled-components/macro';\nimport { Direction } from '../../model/Types';\n\nconst x1 = 30;\nconst y1 = 30;\nconst x2 = 70;\nconst y2 = 70;\nconst x3 = 50;\nconst POINTS = `${x1},${y1} ${x2},${y1} ${x3},${y2} ${x1},${y1}`;\n\nconst DirectionToAngle = {\n  DOWN: 0,\n  LEFT: 90,\n  UP: 180,\n  RIGHT: 270,\n};\n\nexport const WayPoint: React.FC<{\n  screenCoordinates: ScreenCoordinates;\n  color: string;\n  direction: Direction;\n}> = ({ screenCoordinates, color, direction }) => {\n  const angle = DirectionToAngle[direction];\n  return (\n    <SvgStyled\n      viewBox=\"0 0 100 100\"\n      height=\"6\"\n      width=\"6\"\n      style={{\n        left: `${screenCoordinates.x + 1}px`,\n        top: `${screenCoordinates.y}px`,\n      }}\n    >\n      <g transform={`rotate(${angle} 50 50)`}>\n        <polygon points={POINTS} fill={color} stroke={color} strokeWidth={1} />\n      </g>\n    </SvgStyled>\n  );\n};\n\nconst SvgStyled = styled.svg`\n  position: absolute;\n  display: block;\n  width: ${SCREEN_TILE_SIZE}px;\n  height: ${SCREEN_TILE_SIZE}px;\n  pointer-events: none;\n`;\n","/* eslint-disable react/no-unescaped-entities */\nimport { observer } from 'mobx-react-lite';\nimport React from 'react';\nimport { screenFromTile, TileCoordinates } from '../../model/Coordinates';\nimport { WayPoint } from './WayPoint';\nimport { getDirectionFromTileToTile } from '../../model/getDirectionFromTileToTile';\nimport { Direction } from '../../model/Types';\nimport { assert } from '../../util/assert';\n\nexport const WayPoints = observer<{\n  wayPoints: TileCoordinates[];\n  color: string;\n}>(({ wayPoints, color }) => (\n  <>\n    {wayPoints.map((wayPoint, index) => {\n      const screenCoordinates = screenFromTile(wayPoint);\n      const direction = getDirection(wayPoints, index);\n      return (\n        <WayPoint\n          key={index}\n          screenCoordinates={screenCoordinates}\n          color={color}\n          direction={direction}\n        />\n      );\n    })}\n  </>\n));\n\nconst getDirection = (\n  wayPoints: TileCoordinates[],\n  index: number\n): Direction => {\n  if (wayPoints.length <= 1) {\n    return 'DOWN';\n  }\n  const indexToUse = index + 1 < wayPoints.length ? index : index - 1;\n  const fromTile = wayPoints[indexToUse];\n  const toTile = wayPoints[indexToUse + 1];\n  assert(toTile, `${indexToUse} ${wayPoints.length}`);\n  const direction = getDirectionFromTileToTile(fromTile, toTile);\n  return direction;\n};\n","import React, { FC } from 'react';\nimport {\n  TileCoordinates,\n  SCREEN_TILE_SIZE,\n  screenFromTileCoordinate,\n  SCREEN_TILE_CENTER,\n} from '../../../model/Coordinates';\n\nconst SIZE = SCREEN_TILE_SIZE * 2;\nconst OFFSET = SCREEN_TILE_CENTER - SIZE / 2;\n\nexport const Target: FC<{ tile: TileCoordinates; color: string }> = ({\n  tile,\n  color,\n}) => (\n  <div\n    style={{\n      position: 'absolute',\n      left: screenFromTileCoordinate(tile.x) + OFFSET,\n      top: screenFromTileCoordinate(tile.y) + OFFSET,\n      width: SIZE,\n      height: SIZE,\n    }}\n  >\n    <svg version=\"1.1\" viewBox=\"0 0 22 22\">\n      <path\n        style={{ fill: color }}\n        transform={`rotate(45 11 11) translate(-550.29-608.65)`}\n        d=\"m559.29 611.65v1 5h-5-1v4h1 5v5 1h4v-1-5h6v-1-2-1h-1-5v-5-1z\"\n      />\n    </svg>\n  </div>\n);\n","import { observer } from 'mobx-react-lite';\nimport React, { FC } from 'react';\nimport {\n  SCREEN_TILE_SIZE,\n  SCREEN_TILE_CENTER,\n} from '../../../model/Coordinates';\nimport { getGhostHitBox } from '../../../model/detectCollisions';\nimport {\n  Ghost,\n  GhostAnimationPhase,\n  FrightenedGhostTime,\n} from '../../../model/Ghost';\nimport { Direction } from '../../../model/Types';\nimport { WayPoints } from '../../WayFindingPage/WayPoints';\nimport { Box } from '../../../components/Box';\nimport { Sprite } from '../../../components/Sprite';\nimport { useGame, useStore } from '../../../components/StoreContext';\nimport { Target } from './Target';\nimport { GhostViewOptions } from '../../../model/GhostViewOptions';\nimport { GameViewOptions } from '../../../model/GameViewOptions';\n\nconst GHOST_WIDTH = SCREEN_TILE_SIZE * 2;\nconst GHOST_HEIGHT = SCREEN_TILE_SIZE * 2;\n\nconst GHOST_OFFSET_X = GHOST_WIDTH / 2 - 0;\nconst GHOST_OFFSET_Y = GHOST_HEIGHT / 2;\n\nexport const GhostsGameView = observer(() => {\n  const store = useStore();\n  const { ghostViewOptions, gameViewOptions } = store.debugState;\n\n  return (\n    <GhostsView\n      ghostViewOptions={ghostViewOptions}\n      gameViewOptions={gameViewOptions}\n    />\n  );\n});\n\nexport const GhostsView: FC<{\n  ghostViewOptions?: GhostViewOptions;\n  gameViewOptions?: GameViewOptions;\n}> = observer(\n  ({\n    ghostViewOptions = DefaultGhostViewOptions,\n    gameViewOptions = DefaultGameViewOptions,\n  }) => {\n    const store = useGame();\n\n    return (\n      <>\n        {store.ghosts.map(ghost => (\n          <GhostCompositeView\n            key={ghost.ghostNumber}\n            ghost={ghost}\n            ghostViewOptions={ghostViewOptions}\n            gameViewOptions={gameViewOptions}\n          />\n        ))}\n      </>\n    );\n  }\n);\n\nconst DefaultGhostViewOptions: GhostViewOptions = {\n  target: false,\n  wayPoints: false,\n};\n\nconst DefaultGameViewOptions: GameViewOptions = {\n  hitBox: false,\n};\n\nexport const GhostCompositeView: FC<{\n  ghost: Ghost;\n  ghostViewOptions: GhostViewOptions;\n  gameViewOptions: GameViewOptions;\n}> = observer(({ ghost, ghostViewOptions, gameViewOptions }) => {\n  const { screenCoordinates } = ghost;\n  return (\n    <>\n      {gameViewOptions.hitBox && (\n        <GhostHitBox\n          x={screenCoordinates.x + SCREEN_TILE_CENTER}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER}\n          color=\"green\"\n        />\n      )}\n      <GhostView ghost={ghost} />\n      {ghostViewOptions.wayPoints && (\n        <WayPoints wayPoints={ghost.wayPoints ?? []} color={ghost.colorCode} />\n      )}\n      {ghostViewOptions.target && (\n        <Target tile={ghost.targetTile} color={ghost.colorCode} />\n      )}\n    </>\n  );\n});\n\nexport const GhostView: FC<{\n  ghost: Ghost;\n}> = observer(({ ghost }) => {\n  const { screenCoordinates, animationPhase, direction, ghostNumber } = ghost;\n  // TODO\n  switch (ghost.state) {\n    case 'frightened':\n      return (\n        <FrightenedGhostSprite\n          frightenedGhostTime={ghost.frightenedGhostTime}\n          ghostAnimationPhase={animationPhase}\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - GHOST_OFFSET_X}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - GHOST_OFFSET_Y}\n        />\n      );\n    case 'dead':\n      return (\n        <DeadGhostSprite\n          direction={direction}\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - GHOST_OFFSET_X}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - GHOST_OFFSET_Y}\n        />\n      );\n    default:\n      return (\n        <GhostSprite\n          direction={direction}\n          ghostAnimationPhase={animationPhase}\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - GHOST_OFFSET_X}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - GHOST_OFFSET_Y}\n          ghostNumber={ghostNumber}\n        />\n      );\n  }\n});\n\ntype GhostSpriteProps = {\n  direction: Direction;\n  ghostAnimationPhase: GhostAnimationPhase;\n  x: number;\n  y: number;\n  ghostNumber: number;\n  style?: { [key: string]: any };\n};\n\nexport const GhostSprite: FC<GhostSpriteProps> = ({\n  direction,\n  ghostAnimationPhase: phase,\n  x,\n  y,\n  ghostNumber,\n  style,\n}) => (\n  <Sprite\n    className=\"Sprite-ghost\"\n    name={`ghost-${ghostNumber}-direction-${direction}-phase-${phase}`}\n    x={x}\n    y={y}\n    style={style}\n  />\n);\n\ntype DeadGhostSpriteProps = {\n  direction: Direction;\n  x: number;\n  y: number;\n  style?: { [key: string]: any };\n};\n\nexport const DeadGhostSprite: FC<DeadGhostSpriteProps> = ({\n  direction,\n  x,\n  y,\n  style,\n}) => (\n  <Sprite\n    className=\"Sprite-ghost\"\n    name={`dead-ghost-direction-${direction}`}\n    x={x}\n    y={y}\n    style={style}\n  />\n);\n\ntype FrightenedGhostSpriteProps = {\n  x: number;\n  y: number;\n  ghostAnimationPhase: GhostAnimationPhase;\n  frightenedGhostTime: FrightenedGhostTime;\n  style?: { [key: string]: any };\n};\n\nexport const FrightenedGhostSprite: FC<FrightenedGhostSpriteProps> = ({\n  x,\n  y,\n  ghostAnimationPhase,\n  frightenedGhostTime,\n  style,\n}) => (\n  <Sprite\n    className=\"Sprite-ghost\"\n    name={`frightened-ghost-time-${frightenedGhostTime}-phase-${ghostAnimationPhase}`}\n    x={x}\n    y={y}\n    style={style}\n  />\n);\n\nexport const GhostHitBox: FC<{ x: number; y: number; color: string }> = ({\n  x,\n  y,\n  color,\n}) => {\n  const rect = getGhostHitBox({ x, y });\n  return <Box rect={rect} color={color} />;\n};\n","import React, { FC } from 'react';\nimport { Sprite } from '../../../components/Sprite';\n\nexport const MazeView: FC = () => (\n  <Sprite className=\"Sprite-maze\" name=\"maze-state-empty\" x={0} y={0} />\n);\n","import { observer } from 'mobx-react-lite';\nimport React, { FC, memo } from 'react';\nimport { Box } from '../../../components/Box';\nimport { Sprite } from '../../../components/Sprite';\nimport {\n  addCoordinatesAndVector,\n  ScreenCoordinates,\n  screenFromTile,\n  SCREEN_TILE_CENTER_VECTOR,\n  TileCoordinates,\n} from '../../../model/Coordinates';\nimport { getPillHitBox } from '../../../model/detectCollisions';\nimport {\n  BASIC_PILL_ID,\n  ENERGIZER_ID,\n  MAZE_HEIGHT_IN_TILES,\n  MAZE_WIDTH_IN_TILES,\n  EMPTY_TILE_ID,\n} from '../../../model/MazeData';\nimport { useGame } from '../../../components/StoreContext';\n\nconst BasicPillView: FC<{ position: ScreenCoordinates }> = ({ position }) => (\n  <Sprite x={position.x - 10} y={position.y - 10} name=\"basic-pill\" />\n);\n\nconst EnergizerView: FC<{ position: ScreenCoordinates }> = ({ position }) => (\n  <Sprite x={position.x - 10} y={position.y - 10} name=\"energizer\" />\n);\n\nexport const BasicPillHitBox: FC = () => {\n  const rect = getPillHitBox({ x: 1, y: 3 }, BASIC_PILL_ID);\n  return <Box rect={rect} color=\"blue\" />;\n};\n\nconst PillView = observer<{ tile: TileCoordinates }>(\n  ({ tile }: { tile: TileCoordinates }) => {\n    const game = useGame();\n    const { x, y } = tile;\n    const tileId = game.maze.pills[y][x];\n    if (tileId === BASIC_PILL_ID) {\n      return (\n        <BasicPillView\n          position={addCoordinatesAndVector(\n            screenFromTile(tile),\n            SCREEN_TILE_CENTER_VECTOR\n          )}\n        />\n      );\n    }\n    if (tileId === ENERGIZER_ID) {\n      return (\n        <EnergizerView\n          position={addCoordinatesAndVector(\n            screenFromTile(tile),\n            SCREEN_TILE_CENTER_VECTOR\n          )}\n        />\n      );\n    }\n    return null;\n  }\n);\n\n// Performance tricks used here:\n// Make each PillView an observer, so that we don't have to rerender PillsView.\n// Make PillsView a React.memo to prevent any rerenders.\n// Also: Create PillView only for those coordinates where there is a pill on first render.\nexport const PillsView: FC = memo(() => {\n  const game = useGame();\n\n  return (\n    <>\n      {Array.from({ length: MAZE_HEIGHT_IN_TILES }).map((_, y) =>\n        Array.from({ length: MAZE_WIDTH_IN_TILES }).map((_, x) => {\n          const pillFound = game.maze.pills[y][x] !== EMPTY_TILE_ID;\n          return pillFound && <PillView key={`${x}/${y}`} tile={{ x, y }} />;\n        })\n      )}\n    </>\n  );\n});\n\nPillsView.displayName = 'displayName';\n","import { observer } from 'mobx-react-lite';\nimport React from 'react';\nimport { useGame } from '../../../components/StoreContext';\nimport './Score.css';\nimport classNames from 'classnames';\n\nexport const Score = observer<{ className?: string }>(({ className }) => {\n  const store = useGame();\n  return (\n    <div className={classNames('Score', className)}>\n      <span>Score</span>\n      <span>{store.score}</span>\n    </div>\n  );\n});\n","import { action } from 'mobx';\nimport { MAZE_WIDTH_IN_SCREEN_COORDINATES } from './Coordinates';\nimport { PacMan } from './PacMan';\nimport { MilliSeconds } from './Types';\nimport { Vector } from './Vector';\nimport { TotalPacManDyingAnimationLength } from './pacManDyingPhase';\n\nexport const DELAY_TO_REVIVE_PAC_MAN: MilliSeconds = TotalPacManDyingAnimationLength;\n\nexport const movePacManBy = action((pacMan: PacMan, vector: Vector) => {\n  pacMan.screenCoordinates.x =\n    (pacMan.screenCoordinates.x + vector.x + MAZE_WIDTH_IN_SCREEN_COORDINATES) %\n    MAZE_WIDTH_IN_SCREEN_COORDINATES;\n  pacMan.screenCoordinates.y += vector.y;\n});\n","import { ScreenCoordinates, tileFromScreen } from './Coordinates';\nimport { Game } from './Game';\nimport { movePacManBy } from './movePacManBy';\nimport { PacMan } from './PacMan';\nimport { MilliSeconds } from './Types';\nimport {\n  directionToVector as directionAsVector,\n  isTileCenter,\n  isWayFreeInDirection,\n} from './Ways';\nimport { TotalPacManDyingAnimationLength } from './pacManDyingPhase';\n\nexport const DELAY_TO_REVIVE_PAC_MAN: MilliSeconds = TotalPacManDyingAnimationLength;\n\nexport const updatePacMan = (game: Game): void => {\n  const pacMan = game.pacMan;\n  if (pacMan.alive) {\n    updateLivingPacMan(pacMan);\n  } else {\n    updateDeadPacMan(pacMan);\n  }\n};\n\nconst updateLivingPacMan = (pacMan: PacMan) => {\n  if (isTileCenter(pacMan.screenCoordinates)) {\n    const tile = tileFromScreen(pacMan.screenCoordinates);\n\n    // Change direction if necessary\n    if (\n      pacMan.direction !== pacMan.nextDirection &&\n      isWayFreeInDirection(tile, pacMan.nextDirection)\n    ) {\n      pacMan.direction = pacMan.nextDirection;\n    }\n\n    // Move\n    if (isWayFreeInDirection(tile, pacMan.direction)) {\n      movePacMan(pacMan);\n    }\n  } else {\n    movePacMan(pacMan);\n  }\n};\n\nconst movePacMan = (pacMan: PacMan): void => {\n  const speed = pacMan.game.speed;\n  const delta: ScreenCoordinates = directionAsVector(pacMan.direction, speed);\n  movePacManBy(pacMan, delta);\n};\n\nconst updateDeadPacMan = (pacMan: PacMan) => {\n  if (pacMan.timeSinceDeath >= TotalPacManDyingAnimationLength) {\n    revivePacMan(pacMan);\n  }\n  return;\n};\n\nconst revivePacMan = (pacMan: PacMan) => {\n  if (pacMan.extraLivesLeft > 0) {\n    pacMan.extraLivesLeft -= 1;\n    pacMan.game.revivePacMan();\n  }\n};\n","import { action } from 'mobx';\nimport { detectCollisions } from './detectCollisions';\nimport { Game } from './Game';\nimport { updateGhosts } from './updateGhosts';\nimport { updatePacMan } from './updatePacMan';\nimport { updateEnergizerTimer } from './updateEnergizerTimer';\nimport { updateExternalTimestamp } from './updateExternalTimeStamp';\nimport { updateGameTimestamp } from './updateGameTimestamp';\n\nexport const onAnimationFrame = action(\n  'onAnimationFrame',\n  ({ game, timestamp }: { game: Game; timestamp: number }) => {\n    updateExternalTimestamp({ game, externalTimeStamp: timestamp });\n\n    if (game.gamePaused) {\n      return;\n    }\n\n    updateGameTimestamp(game);\n    updateEnergizerTimer(game);\n    updatePacMan(game);\n    updateGhosts(game);\n    detectCollisions(game);\n  }\n);\n","import { Game } from './Game';\nimport { MilliSeconds } from './Types';\n\n// The typical duration of a frame: 1000ms for 60 frames per second = 17ms.\nexport const TYPICAL_FRAME_LENGTH: MilliSeconds = 17;\n\nexport const updateExternalTimestamp = ({\n  game,\n  externalTimeStamp,\n}: {\n  game: Game;\n  externalTimeStamp: number;\n}) => {\n  if (game.externalTimeStamp === null) {\n    // The very first frame\n    // We cannot measure its duration. Therefore we have to make an assumption.\n    game.lastFrameLength = TYPICAL_FRAME_LENGTH;\n  } else {\n    // A later frame.\n    // We can calculate its duration.\n    game.lastFrameLength = externalTimeStamp - game.externalTimeStamp;\n  }\n  game.externalTimeStamp = externalTimeStamp;\n};\n","import { Game } from './Game';\n\nexport const updateGameTimestamp = (game: Game) => {\n  game.timestamp += game.lastFrameLength;\n  game.frameCount++;\n};\n","import { Game } from './Game';\n\nexport const updateEnergizerTimer = (game: Game) => {\n  game.energizerTimer.advance(game.lastFrameLength);\n};\n","import { useStore } from '../components/StoreContext';\nimport { onAnimationFrame } from './onAnimationFrame';\nimport { useAnimationLoop } from './useAnimationLoop';\n\nexport const useGameLoop = () => {\n  const store = useStore();\n\n  const animationStep = (timestamp: number) => {\n    const { game } = store;\n    onAnimationFrame({ game, timestamp });\n  };\n\n  useAnimationLoop(animationStep);\n};\n","import { useEffect, useRef } from 'react';\nimport { MilliSeconds } from './Types';\n\ntype AnimationStepFunc = (timestamp: MilliSeconds) => void;\n\nexport const useAnimationLoop = (animationStep: AnimationStepFunc) => {\n  const requestRef = useRef(-1);\n\n  const animate = (timestamp: number) => {\n    animationStep(timestamp);\n    requestRef.current = requestAnimationFrame(animate);\n  };\n\n  useEffect(() => {\n    requestAnimationFrame(animate);\n    return () => {\n      cancelAnimationFrame(requestRef.current);\n    };\n    // eslint-disable-next-line  react-hooks/exhaustive-deps\n  }, []);\n};\n","import { Row } from 'antd';\nimport { observer } from 'mobx-react-lite';\nimport React, { useEffect } from 'react';\nimport styled from 'styled-components/macro';\nimport { Board } from '../../components/Board';\nimport { DebugView } from './components/DebugView';\nimport { ExtraLives } from './components/ExtraLives';\nimport { GameOver } from './components/GameOver';\nimport { GhostsGameView } from './components/GhostsView';\nimport { MazeView } from './components/MazeView';\nimport { PacManView } from './components/PacManView';\nimport { PillsView } from './components/PillsView';\nimport { Score } from './components/Score';\nimport { useStore } from '../../components/StoreContext';\nimport { useKeyboardActions } from './components/useKeyboardActions';\nimport { VSpace } from '../../components/Spacer';\nimport { useGameLoop } from '../../model/useGameLoop';\n\nexport const GamePage: React.FC = observer(() => {\n  const store = useStore();\n  useEffect(() => {\n    store.resetGame();\n    return () => {\n      store.game.gamePaused = true;\n    };\n    // eslint-disable-next-line  react-hooks/exhaustive-deps\n  }, []);\n\n  useGameLoop();\n  useKeyboardActions();\n\n  return (\n    <Layout data-testid=\"GamePage\">\n      <ScoreArea>\n        <Row justify=\"center\">\n          <Score />\n        </Row>\n        <VSpace size=\"small\" />\n      </ScoreArea>\n\n      <EmptyArea />\n\n      <BoardArea>\n        <Board>\n          <MazeView />\n          <PillsView />\n          <PacManView />\n          <GhostsGameView />\n          <GameOver />\n        </Board>\n        <VSpace size=\"large\" />\n        <Row justify=\"center\">\n          <ExtraLives />\n        </Row>\n      </BoardArea>\n\n      <DebugArea>\n        <DebugView />\n      </DebugArea>\n    </Layout>\n  );\n});\n\nconst Layout = styled.div`\n  margin-left: 16px;\n  margin-right: 16px;\n\n  display: grid;\n\n  @media (min-width: 1280px) {\n    grid-template-columns: 1fr 1fr;\n    justify-items: center;\n  }\n  @media (max-width: 1280px) {\n    grid-template-columns: 1fr;\n    justify-items: center;\n  }\n`;\n\nconst ScoreArea = styled.div``;\n\nconst EmptyArea = styled.div``;\n\nconst BoardArea = styled.div``;\n\nconst DebugArea = styled.div`\n  @media (max-width: 1280px) {\n    display: none;\n  }\n`;\n","import { useCallback, useEffect } from 'react';\nimport { useStore } from '../../../components/StoreContext';\n\n/* eslint-disable  react-hooks/exhaustive-deps */\nexport const useKeyboardActions = (): void => {\n  const store = useStore();\n\n  const onKeyDown = useCallback((event: KeyboardEvent) => {\n    const { game } = store;\n    const pressedKey = event.key;\n    const pacMan = game.pacMan;\n    switch (pressedKey) {\n      case 'ArrowLeft':\n        pacMan.nextDirection = 'LEFT';\n        break;\n      case 'ArrowRight':\n        pacMan.nextDirection = 'RIGHT';\n        break;\n      case 'ArrowUp':\n        pacMan.nextDirection = 'UP';\n        break;\n      case 'ArrowDown':\n        pacMan.nextDirection = 'DOWN';\n        break;\n      case ' ':\n        game.gamePaused = !game.gamePaused;\n        break;\n      default:\n        break;\n    }\n  }, []);\n\n  useEffect(() => {\n    document.addEventListener('keydown', onKeyDown);\n\n    return () => {\n      document.removeEventListener('keydown', onKeyDown);\n    };\n  }, []);\n};\n","import React, { FC, useState } from 'react';\nimport {\n  SCREEN_TILE_SIZE,\n  TileCoordinates,\n  ScreenCoordinates,\n} from '../model/Coordinates';\n\nimport './Grid.css';\nimport { waysMatrix, getPillsMatrix } from '../model/MazeData';\n\nconst ROWS = 31;\nconst COLUMNS = 28;\n\nexport const GridWithHoverCoordinates: FC<{\n  screenCoordinates: ScreenCoordinates;\n  onClick?: (\n    coordinates: TileCoordinates,\n    event: React.MouseEvent<HTMLDivElement, MouseEvent>\n  ) => void; // eslint-disable-next-line @typescript-eslint/no-empty-function\n}> = ({ screenCoordinates, onClick }) => {\n  const [coordinates, setCoordinates] = useState<TileCoordinates | null>(null);\n  const pillsMatrix = getPillsMatrix();\n  const { x, y } = screenCoordinates;\n  return (\n    <>\n      <Grid x={x} y={y} onHover={setCoordinates} onClick={onClick} />\n      <div\n        style={{\n          position: 'absolute',\n          left: `${x}px`,\n          top: `${y + ROWS * SCREEN_TILE_SIZE}px`,\n          height: '20px',\n        }}\n      >\n        {coordinates &&\n          `${coordinates.x} / ${coordinates.y} - ways layer id: ${\n            waysMatrix[coordinates.y][coordinates.x]\n          } - pills layer id: ${\n            pillsMatrix[coordinates.y][coordinates.x]\n          }`}{' '}\n        &nbsp;\n      </div>\n    </>\n  );\n};\n\nexport const Grid: FC<{\n  x: number;\n  y: number;\n  onClick?: (\n    coordinates: TileCoordinates,\n    event: React.MouseEvent<HTMLDivElement, MouseEvent>\n  ) => void;\n  onHover: (coordinates: TileCoordinates | null) => void;\n}> = ({ x, y, onClick, onHover }) => {\n  return (\n    <div\n      className={'Grid'}\n      style={{\n        position: 'absolute',\n        left: `${x}px`,\n        top: `${y}px`,\n        gridTemplateColumns: `repeat(${COLUMNS}, ${SCREEN_TILE_SIZE}px)`,\n        gridTemplateRows: `repeat(${ROWS}, ${SCREEN_TILE_SIZE}PX)`,\n      }}\n    >\n      {Array(ROWS)\n        .fill(null)\n        .map((_, rowIndex) =>\n          Array.from({ length: COLUMNS }).map((_, columnIndex) => (\n            <div\n              className=\"GridCell\"\n              key={`${columnIndex}/${rowIndex}`}\n              onClick={(\n                event: React.MouseEvent<HTMLDivElement, MouseEvent>\n              ) => {\n                if (onClick) {\n                  onClick({ x: columnIndex, y: rowIndex }, event);\n                }\n              }}\n              onMouseEnter={() => onHover({ x: columnIndex, y: rowIndex })}\n              onMouseLeave={() => onHover(null)}\n            />\n          ))\n        )}\n    </div>\n  );\n};\n","import React from 'react';\nimport { GridWithHoverCoordinates } from '../../components/Grid';\nimport { PacManSprite } from '../GamePage/components/PacManView';\nimport { BasicPillHitBox, PillsView } from '../GamePage/components/PillsView';\nimport { Sprite } from '../../components/Sprite';\nimport {\n  screenFromTileCoordinate,\n  SCREEN_TILE_CENTER,\n} from '../../model/Coordinates';\nimport styled from 'styled-components/macro';\nimport { Row, Col } from 'antd';\n\nexport const MazePage: React.FC = () => {\n  return (\n    <Layout data-testid=\"MazePage\">\n      <Row justify=\"space-around\">\n        <Col flex=\"562px\">\n          <RelativeAbsoluteLayout>\n            <Sprite\n              className=\"Sprite-maze\"\n              name=\"maze-state-empty\"\n              x={0}\n              y={0}\n            />\n            <GridWithHoverCoordinates screenCoordinates={{ x: 0, y: 0 }} />\n            <PillsView />\n          </RelativeAbsoluteLayout>\n        </Col>\n\n        <Col flex=\"562px\">\n          <RelativeAbsoluteLayout>\n            <Sprite\n              className=\"Sprite-maze\"\n              name=\"maze-state-empty\"\n              x={0}\n              y={0}\n            />\n            <GridWithHoverCoordinates screenCoordinates={{ x: 0, y: 0 }} />\n            <Sprite x={20 * 1} y={20 * 1} name=\"basic-pill\"></Sprite>\n            <Sprite x={20 * 1} y={20 * 3} name=\"energizer\"></Sprite>\n            <Sprite x={20 * 6} y={20 * 10} name=\"energizer\"></Sprite>\n            <PacManSprite\n              direction=\"RIGHT\"\n              pacManAnimationPhase={1}\n              x={screenFromTileCoordinate(1) + SCREEN_TILE_CENTER}\n              y={screenFromTileCoordinate(4) + SCREEN_TILE_CENTER}\n            />\n            <BasicPillHitBox />\n          </RelativeAbsoluteLayout>\n        </Col>\n      </Row>\n    </Layout>\n  );\n};\n\nconst Layout = styled.div`\n  margin: 32px;\n`;\n\nconst RelativeAbsoluteLayout = styled.div`\n  position: relative;\n`;\n","import { Ghost } from './Ghost';\nimport { DIRECTION_TO_OPPOSITE_DIRECTION } from './Ways';\n\nexport const changeDirectionToOpposite = (ghost: Ghost) => {\n  ghost.direction = DIRECTION_TO_OPPOSITE_DIRECTION[ghost.direction];\n};\n","import { TileCoordinates } from './Coordinates';\nimport { Direction } from './Types';\nimport { isEqual } from 'lodash';\nimport { chooseNextTile } from './chooseNextTile';\nimport { getDirectionFromTileToTile } from './getDirectionFromTileToTile';\n\nexport const findWayPoints = (\n  origin: TileCoordinates,\n  destination: TileCoordinates,\n  currentDirection: Direction,\n  boxDoorIsOpen: boolean\n): TileCoordinates[] | null => {\n  const way: TileCoordinates[] = [origin];\n  let currentTile = origin;\n  let workingDirection = currentDirection;\n  while (!isEqual(currentTile, destination)) {\n    const nextTile = chooseNextTile({\n      currentTile,\n      currentDirection: workingDirection,\n      targetTile: destination,\n      boxDoorIsOpen,\n    });\n    // Prevent endless iteration\n    if (way.some(wayPoint => isEqual(wayPoint, nextTile))) {\n      return way;\n    }\n    way.push(nextTile);\n    workingDirection = getDirectionFromTileToTile(\n      currentTile,\n      nextTile\n    ) as Direction;\n    currentTile = nextTile;\n  }\n  return way;\n};\n","/* eslint-disable @typescript-eslint/ban-types */\n\nimport { Machine, interpret, State } from 'xstate';\n\nexport const INITIAL_GHOST_STATE = 'scatter';\n\ninterface GhostEventHandler {\n  onScatterToChase(): void;\n  onChaseToScatter(): void;\n  onDead(): void;\n}\n\ntype GhostContext = {};\n\ninterface GhostStateSchema {\n  states: {\n    chase: {};\n    scatter: {};\n    frightened: {};\n    dead: {};\n  };\n}\n\nexport type GhostEventType =\n  | 'RESET'\n  | 'ENERGIZER_EATEN'\n  | 'ENERGIZER_TIMED_OUT'\n  | 'PHASE_END'\n  | 'COLLISION_WITH_PAC_MAN'\n  | 'REVIVED';\n\ntype GhostEvent = { type: GhostEventType };\n\nexport type GhostState = State<GhostContext, GhostEvent, GhostStateSchema, any>;\n\nconst GhostStateChart = Machine<GhostContext, GhostStateSchema, GhostEvent>({\n  id: 'ghost',\n  initial: INITIAL_GHOST_STATE,\n  on: {\n    RESET: INITIAL_GHOST_STATE,\n  },\n  states: {\n    chase: {\n      on: {\n        ENERGIZER_EATEN: 'frightened',\n        PHASE_END: {\n          target: 'scatter',\n          actions: 'onChaseToScatter',\n        },\n        COLLISION_WITH_PAC_MAN: {\n          target: 'scatter',\n        },\n      },\n    },\n    scatter: {\n      on: {\n        ENERGIZER_EATEN: 'frightened',\n        PHASE_END: {\n          target: 'chase',\n          actions: 'onScatterToChase',\n        },\n        COLLISION_WITH_PAC_MAN: {\n          target: 'scatter',\n        },\n      },\n    },\n    frightened: {\n      on: {\n        ENERGIZER_TIMED_OUT: 'chase',\n        COLLISION_WITH_PAC_MAN: {\n          target: 'dead',\n          actions: 'onDead',\n        },\n      },\n    },\n    dead: {\n      on: {\n        REVIVED: 'scatter',\n        ENERGIZER_TIMED_OUT: 'scatter',\n      },\n    },\n  },\n});\n\nexport const makeGhostStateChart = (eventHandler: GhostEventHandler) => {\n  const extended = GhostStateChart.withConfig({\n    actions: {\n      onScatterToChase: eventHandler.onScatterToChase,\n      onChaseToScatter: eventHandler.onChaseToScatter,\n      onDead: eventHandler.onDead,\n    },\n  });\n  const stateChart = interpret(extended);\n  return stateChart;\n};\n","import { MilliSeconds } from './Types';\nimport { observable, computed, action } from 'mobx';\n\nexport type TimerCallback = () => void;\n\nexport class TimeoutTimer {\n  duration: MilliSeconds;\n  readonly onTimedOut: TimerCallback | null;\n\n  @observable\n  running: boolean;\n\n  @observable\n  timeSpent: MilliSeconds;\n\n  constructor(duration: MilliSeconds, onTimedOut: TimerCallback | null = null) {\n    this.duration = duration;\n    this.onTimedOut = onTimedOut;\n    this.running = false;\n    this.timeSpent = 0;\n  }\n\n  @action\n  setDuration(duration: MilliSeconds) {\n    this.duration = duration;\n  }\n\n  @action.bound\n  start() {\n    this.running = true;\n    this.timeSpent = 0;\n  }\n\n  @action\n  advance(timePassed: MilliSeconds) {\n    if (!this.running) {\n      return;\n    }\n    this.timeSpent += timePassed;\n    if (this.isTimedOut) {\n      this.onTimedOut?.();\n      this.stop();\n    }\n  }\n\n  @action\n  stop() {\n    this.running = false;\n  }\n\n  restart() {\n    this.stop();\n    this.start();\n  }\n\n  @computed\n  get timeLeft() {\n    return this.duration - this.timeSpent;\n  }\n\n  @computed\n  get isTimedOut() {\n    return this.timeSpent >= this.duration;\n  }\n}\n","import { action, computed, observable } from 'mobx';\nimport { changeDirectionToOpposite } from './changeDirectionToOpposite';\nimport {\n  ScreenCoordinates,\n  screenFromTile,\n  TileCoordinates,\n  tileFromScreen,\n} from './Coordinates';\nimport { findWayPoints } from './findWayPoints';\nimport { Game } from './Game';\nimport {\n  GhostEventType,\n  makeGhostStateChart,\n  GhostState,\n} from './GhostStateChart';\nimport { Direction, MilliSeconds } from './Types';\nimport {\n  isTileInBox as isTileInBoxWalls,\n  isTileCenter,\n  isTileInBoxSpace,\n} from './Ways';\nimport { StateValue } from 'xstate';\nimport { TimeoutTimer } from './TimeoutTimer';\nimport { getStatePhaseLength } from './updateGhostStatePhase';\n\nexport type GhostNumber = 0 | 1 | 2 | 3;\nexport const GhostNumbers: GhostNumber[] = [0, 1, 2, 3];\nexport type GhostAnimationPhase = 0 | 1;\nexport const GhostAnimationPhases: GhostAnimationPhase[] = [0, 1];\nexport type FrightenedGhostTime = 0 | 1;\nexport const FrightenedGhostTimes: FrightenedGhostTime[] = [0, 1];\n\nconst FRIGHTENED_ABOUT_TO_END_DURATION: MilliSeconds = 3000;\nconst DEAD_WAITING_IN_BOX_DURATION: MilliSeconds = 3000;\n\nexport const KILL_GHOST_SCORE = [0, 100, 200, 400, 800, 1600, 3200];\n\nexport class Ghost {\n  constructor(game: Game) {\n    this.game = game;\n\n    this.stateChart.onTransition(this.handleStateTransition);\n    this.stateChart.start();\n  }\n\n  @action.bound\n  handleStateTransition(state: GhostState) {\n    if (!state.changed) {\n      return;\n    }\n    this.stateChartState = state;\n    this.stateChanges++;\n  }\n\n  stateChart = makeGhostStateChart({\n    onScatterToChase: this.onScatterToChase,\n    onChaseToScatter: this.onChaseToScatter,\n    onDead: this.onDead,\n  });\n\n  @action.bound\n  onDead() {\n    this.game.killedGhosts++;\n    this.game.score += KILL_GHOST_SCORE[this.game.killedGhosts];\n    this.deadWaitingTimeInBoxLeft = DEAD_WAITING_IN_BOX_DURATION;\n  }\n\n  @action.bound\n  onScatterToChase() {\n    changeDirectionToOpposite(this);\n  }\n\n  @action.bound\n  onChaseToScatter() {\n    changeDirectionToOpposite(this);\n  }\n\n  @observable.ref\n  stateChartState: GhostState = this.stateChart.state;\n\n  @computed\n  get state(): StateValue {\n    return this.stateChartState.value;\n  }\n\n  @observable\n  stateChanges = 0;\n\n  @computed\n  get dead() {\n    return this.stateChartState.matches('dead');\n  }\n\n  @computed\n  get alive() {\n    return !this.dead;\n  }\n\n  @computed get frightened(): boolean {\n    return this.stateChartState.matches('frightened');\n  }\n\n  name = 'ghost name';\n\n  send(event: GhostEventType) {\n    this.stateChart.send(event);\n  }\n\n  @observable\n  ghostPaused = true;\n\n  game: Game;\n\n  @observable\n  ghostNumber: GhostNumber = 0;\n\n  color = 'ghost color';\n  colorCode = '#00ffff';\n\n  @observable\n  screenCoordinates: ScreenCoordinates = {\n    x: 16,\n    y: 16,\n  };\n\n  @computed\n  get atTileCenter(): boolean {\n    return isTileCenter(this.screenCoordinates);\n  }\n\n  @observable\n  speedFactor = 1;\n\n  @action\n  setTileCoordinates(tile: TileCoordinates) {\n    this.screenCoordinates = screenFromTile(tile);\n  }\n\n  @computed\n  get tileCoordinates(): TileCoordinates {\n    return tileFromScreen(this.screenCoordinates);\n  }\n\n  @computed\n  get animationPhase(): GhostAnimationPhase {\n    return Math.round((this.game.timestamp + this.ghostNumber * 100) / 300) %\n      2 ===\n      0\n      ? 0\n      : 1;\n  }\n\n  @computed\n  get frightenedAboutToEnd(): boolean {\n    return this.game.energizerTimer.timeLeft < FRIGHTENED_ABOUT_TO_END_DURATION;\n  }\n\n  @observable\n  deadWaitingTimeInBoxLeft: MilliSeconds = 0;\n\n  @computed\n  get frightenedGhostTime(): FrightenedGhostTime {\n    if (!this.frightenedAboutToEnd) {\n      return 0;\n    }\n    // Blink every 0.5 seconds\n    return this.game.timestamp % 1000 < 500 ? 0 : 1;\n  }\n\n  @observable\n  direction: Direction = 'LEFT';\n\n  @observable\n  targetTile: TileCoordinates = { x: 1, y: 1 };\n\n  @computed\n  get wayPoints(): TileCoordinates[] | null {\n    return findWayPoints(\n      this.tileCoordinates,\n      this.targetTile,\n      this.direction,\n      this.canPassThroughBoxDoor\n    );\n  }\n\n  statePhaseTimer = new TimeoutTimer(3000);\n\n  @computed\n  get isInsideBoxWalls(): boolean {\n    return isTileInBoxWalls(this.tileCoordinates);\n  }\n\n  @computed\n  get isOutsideBoxSpace() {\n    return !isTileInBoxSpace(this.tileCoordinates);\n  }\n\n  @computed\n  get canPassThroughBoxDoor(): boolean {\n    if (this.alive) {\n      if (this.isInsideBoxWalls) {\n        if (this.game.timestamp > this.initialWaitingTimeInBox) {\n          return true;\n        }\n      }\n    }\n\n    if (this.dead) {\n      if (this.isOutsideBoxSpace) {\n        return true;\n      }\n\n      // Dead && Inside box\n      if (this.deadWaitingTimeInBoxLeft <= 0) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  @action\n  resetGhost() {\n    this.ghostPaused = false;\n    this.send('RESET');\n    this.statePhaseTimer.setDuration(getStatePhaseLength(this.state));\n    this.statePhaseTimer.restart();\n  }\n\n  initialWaitingTimeInBox = 0;\n}\n","import React, { useEffect, useState } from 'react';\nimport {\n  PacManAnimationPhase,\n  PacManAnimationPhases,\n  PacManSprite,\n  DyingPacManSprite,\n} from '../GamePage/components/PacManView';\nimport {\n  GhostSprite,\n  DeadGhostSprite,\n  FrightenedGhostSprite,\n} from '../GamePage/components/GhostsView';\nimport { Directions, Direction } from '../../model/Types';\nimport { Sprite } from '../../components/Sprite';\nimport {\n  GhostAnimationPhases,\n  GhostNumbers,\n  GhostAnimationPhase,\n  GhostNumber,\n  FrightenedGhostTimes,\n} from '../../model/Ghost';\nimport styled from 'styled-components/macro';\nimport {\n  PacManDyingPhaseCount,\n  PacManDyingPhase,\n  PacManDyingPhases,\n} from '../../model/pacManDyingPhase';\n\nexport const SpritePage: React.FC = () => {\n  const [phaseCounter, setPhaseCounter] = useState<number>(0);\n  const [directionIndex, setDirectionIndex] = useState<number>(0);\n  const pacManPhase = (phaseCounter %\n    PacManAnimationPhases.length) as PacManAnimationPhase;\n  const ghostPhase = (phaseCounter %\n    GhostAnimationPhases.length) as GhostAnimationPhase;\n  const dyingPacManAnimationPhase = (phaseCounter %\n    PacManDyingPhaseCount) as PacManDyingPhase;\n\n  useEffect(() => {\n    const timerId = setInterval(() => {\n      setPhaseCounter((phaseCounter: number) => phaseCounter + 1);\n    }, 300);\n    return () => {\n      clearInterval(timerId);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  useEffect(() => {\n    const timerId = setInterval(() => {\n      setDirectionIndex((directionIndex: number) =>\n        directionIndex === 3 ? 0 : directionIndex + 1\n      );\n    }, 1000);\n    return () => {\n      clearInterval(timerId);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  const direction = Directions[directionIndex];\n  return (\n    <Layout className=\"SpriteTestPage\" data-testid=\"SpritePage\">\n      {GhostNumbers.map((ghostNumber: GhostNumber) =>\n        Directions.map((direction: Direction, directionIndex: number) =>\n          GhostAnimationPhases.map((ghostPhase: GhostAnimationPhase) => (\n            <GhostSprite\n              key={`${ghostPhase}-${direction}-${ghostPhase}`}\n              direction={direction}\n              ghostAnimationPhase={ghostPhase}\n              x={directionIndex * 160 + ghostPhase * 80}\n              y={ghostNumber * 60}\n              ghostNumber={ghostNumber}\n            />\n          ))\n        )\n      )}\n\n      {FrightenedGhostTimes.map(frightenedGhostTime =>\n        GhostAnimationPhases.map(ghostAnimationPhase => (\n          <FrightenedGhostSprite\n            key={`${ghostAnimationPhase}-${frightenedGhostTime}`}\n            ghostAnimationPhase={ghostAnimationPhase}\n            frightenedGhostTime={frightenedGhostTime}\n            x={ghostAnimationPhase * 80 + frightenedGhostTime * 160}\n            y={4 * 60}\n          />\n        ))\n      )}\n\n      {Directions.map((direction: Direction, directionIndex: number) => (\n        <DeadGhostSprite\n          key={directionIndex}\n          direction={direction}\n          x={directionIndex * 80}\n          y={5 * 60}\n        />\n      ))}\n\n      {Directions.map((direction: Direction, directionIndex: number) =>\n        PacManAnimationPhases.map((pacManPhase: PacManAnimationPhase) => (\n          <PacManSprite\n            key={pacManPhase}\n            direction={direction}\n            pacManAnimationPhase={pacManPhase}\n            x={directionIndex * 160 + pacManPhase * 80}\n            y={6 * 60}\n          />\n        ))\n      )}\n\n      {PacManDyingPhases.map(dyingPacManPhase => (\n        <DyingPacManSprite\n          key={dyingPacManPhase}\n          dyingPacManAnimationPhase={dyingPacManPhase}\n          x={dyingPacManPhase * 45}\n          y={7 * 60}\n        />\n      ))}\n\n      {GhostNumbers.map(ghostNumber => (\n        <GhostSprite\n          key={ghostNumber}\n          direction={direction}\n          ghostAnimationPhase={ghostPhase}\n          x={ghostNumber * 80}\n          y={8 * 60}\n          ghostNumber={ghostNumber}\n        />\n      ))}\n      <FrightenedGhostSprite\n        ghostAnimationPhase={ghostPhase}\n        frightenedGhostTime={0}\n        x={4 * 80}\n        y={8 * 60}\n      />\n      <FrightenedGhostSprite\n        ghostAnimationPhase={ghostPhase}\n        frightenedGhostTime={1}\n        x={5 * 80}\n        y={8 * 60}\n      />\n\n      <DeadGhostSprite direction={direction} x={6 * 80} y={8 * 60} />\n\n      <PacManSprite\n        direction={direction}\n        pacManAnimationPhase={pacManPhase}\n        x={7 * 80}\n        y={8 * 60}\n      />\n\n      <DyingPacManSprite\n        dyingPacManAnimationPhase={dyingPacManAnimationPhase}\n        x={0 + 0 * 80}\n        y={9 * 60}\n      />\n\n      <Sprite x={0 + 0 * 80} y={10 * 60} name=\"basic-pill\"></Sprite>\n      <Sprite x={0 + 1 * 80} y={10 * 60} name=\"energizer\"></Sprite>\n    </Layout>\n  );\n};\n\nconst Layout = styled.div`\n  position: relative;\n  margin-top: 50px;\n  margin-left: 100px;\n  width: 800px;\n  height: 600px;\n`;\n","/* eslint-disable react/no-unescaped-entities */\nimport React from 'react';\nimport { Sprite } from '../../components/Sprite';\nimport { GridWithHoverCoordinates } from '../../components/Grid';\n\nimport { PacManSprite } from '../GamePage/components/PacManView';\nimport { GhostSprite } from '../GamePage/components/GhostsView';\nimport {\n  screenFromTileCoordinate,\n  TileCoordinates,\n  SCREEN_TILE_CENTER,\n} from '../../model/Coordinates';\nimport { useLocalStore, observer } from 'mobx-react-lite';\nimport { action } from 'mobx';\n\nimport { WayPoints } from './WayPoints';\nimport { findWayPoints } from '../../model/findWayPoints';\nimport styled from 'styled-components/macro';\nimport { Row } from 'antd';\n\nexport const WayFindingPage = observer(() => {\n  const localStore = useLocalStore(() => ({\n    origin: { x: 1, y: 1 } as TileCoordinates,\n    destination: { x: 6, y: 15 } as TileCoordinates,\n    setOrigin: action((value: TileCoordinates) => {\n      localStore.origin = value;\n    }),\n    setDestination: action((value: TileCoordinates) => {\n      localStore.destination = value;\n    }),\n  }));\n\n  const wayPoints =\n    findWayPoints(localStore.origin, localStore.destination, 'RIGHT', true) ??\n    [];\n\n  return (\n    <Layout data-testid=\"WayfindingPage\">\n      <Row justify=\"center\">\n        <RelativeAbsoluteLayout>\n          <Sprite className=\"Sprite-maze\" name=\"maze-state-empty\" x={0} y={0} />\n\n          <GridWithHoverCoordinates\n            screenCoordinates={{ x: 0, y: 0 }}\n            onClick={(\n              coordinates: TileCoordinates,\n              event: React.MouseEvent<HTMLDivElement, MouseEvent>\n            ) => {\n              if (event.shiftKey) {\n                localStore.setOrigin(coordinates);\n              } else {\n                localStore.setDestination(coordinates);\n              }\n            }}\n          />\n\n          <GhostSprite\n            direction=\"RIGHT\"\n            ghostAnimationPhase={1}\n            x={\n              screenFromTileCoordinate(localStore.origin.x - 1) +\n              SCREEN_TILE_CENTER\n            }\n            y={\n              screenFromTileCoordinate(localStore.origin.y - 1) +\n              SCREEN_TILE_CENTER\n            }\n            ghostNumber={0}\n          />\n\n          <PacManSprite\n            direction=\"RIGHT\"\n            pacManAnimationPhase={1}\n            x={\n              screenFromTileCoordinate(localStore.destination.x - 1) +\n              SCREEN_TILE_CENTER\n            }\n            y={\n              screenFromTileCoordinate(localStore.destination.y - 1) +\n              SCREEN_TILE_CENTER\n            }\n            style={{}}\n          />\n\n          <WayPoints wayPoints={wayPoints} color=\"#e2a12b\"></WayPoints>\n          <div style={{ position: 'absolute', top: 660, width: '300px' }}>\n            Click sets pac man's position\n            <br /> Shift-Click sets ghost position\n          </div>\n        </RelativeAbsoluteLayout>\n      </Row>\n    </Layout>\n  );\n});\n\nconst Layout = styled.div`\n  margin-top: 32px;\n`;\n\nconst RelativeAbsoluteLayout = styled.div`\n  position: relative;\n  width: 560px;\n`;\n","import React from 'react';\nimport { Route, Switch } from 'react-router-dom';\n\nimport { GamePage } from './pages/GamePage/GamePage';\nimport { MazePage } from './pages/MazePage/MazePage';\nimport { SpritePage } from './pages/SpritePage/SpritePage';\nimport { WayFindingPage } from './pages/WayFindingPage/WayFindingPage';\n\nexport const Routes: React.FC = () => {\n  return (\n    <Switch>\n      <Route path=\"/\" exact>\n        <GamePage />\n      </Route>\n      <Route path=\"/sprites\">\n        <SpritePage />\n      </Route>\n      <Route path=\"/maze\">\n        <MazePage />\n      </Route>\n      <Route path=\"/way-finding\">\n        <WayFindingPage />\n      </Route>\n    </Switch>\n  );\n};\n","import { Menu } from 'antd';\nimport React from 'react';\nimport { useHistory, useLocation } from 'react-router-dom';\nimport styled from 'styled-components';\nimport { VSpace } from './Spacer';\n\nexport const AppMenu: React.FC = () => {\n  const location = useLocation();\n  const history = useHistory();\n  const selectedKey = location.pathname;\n  return (\n    <div className=\"AppMenu\">\n      <MenuStyled\n        mode=\"horizontal\"\n        onClick={event => {\n          history.push(event.key.toString());\n        }}\n        selectedKeys={[selectedKey]}\n      >\n        <Menu.Item key=\"/\">Home</Menu.Item>\n        <Menu.Item key=\"/sprites\">Sprites</Menu.Item>\n        <Menu.Item key=\"/maze\">Maze</Menu.Item>\n        <Menu.Item key=\"/way-finding\">Way Finding</Menu.Item>\n      </MenuStyled>\n      <VSpace size=\"large\" />\n    </div>\n  );\n};\n\nconst MenuStyled = styled(Menu)`\n  background-color: inherit;\n  border-bottom: none;\n  margin-left: 4px;\n\n  .ant-menu-item {\n    color: white;\n  }\n`;\n","import { Game } from './Game';\nimport { Ghost } from './Ghost';\n\nexport const resetGhosts = (ghosts: Ghost[]) => {\n  ghosts[0].setTileCoordinates({ x: 12, y: 14 });\n  ghosts[0].direction = 'LEFT';\n  ghosts[1].setTileCoordinates({ x: 13, y: 14 });\n  ghosts[1].direction = 'RIGHT';\n  ghosts[2].setTileCoordinates({ x: 14, y: 14 });\n  ghosts[3].direction = 'LEFT';\n  ghosts[3].setTileCoordinates({ x: 15, y: 14 });\n  ghosts[3].direction = 'RIGHT';\n\n  for (const ghost of ghosts) {\n    ghost.resetGhost();\n  }\n};\n\nexport const makeGhosts = (game: Game): Ghost[] => {\n  const ghosts: Ghost[] = [\n    new Ghost(game),\n    new Ghost(game),\n    new Ghost(game),\n    new Ghost(game),\n  ];\n\n  ghosts[0].ghostNumber = 0;\n  ghosts[0].name = 'Blinky';\n  ghosts[0].color = 'red';\n  ghosts[0].colorCode = '#ff0000';\n  ghosts[0].initialWaitingTimeInBox = 1000;\n\n  ghosts[1].ghostNumber = 1;\n  ghosts[1].name = 'Pinky';\n  ghosts[1].color = 'pink';\n  ghosts[1].colorCode = '#fcb5ff';\n  ghosts[1].initialWaitingTimeInBox = 1300;\n\n  ghosts[2].ghostNumber = 2;\n  ghosts[2].name = 'Inky';\n  ghosts[2].color = 'blue';\n  ghosts[2].colorCode = '#00ffff';\n  ghosts[2].initialWaitingTimeInBox = 1600;\n\n  ghosts[3].ghostNumber = 3;\n  ghosts[3].name = 'Clyde';\n  ghosts[3].color = 'orange';\n  ghosts[3].colorCode = '#f9ba55';\n  ghosts[3].initialWaitingTimeInBox = 1900;\n\n  resetGhosts(ghosts);\n\n  return ghosts;\n};\n","import { observable } from 'mobx';\nimport { getPillsMatrix, TileId } from './MazeData';\n\nexport class Maze {\n  @observable\n  pills: TileId[][] = getPillsMatrix();\n}\n","/* eslint-disable @typescript-eslint/ban-types */\n\nimport { Machine, interpret, State } from 'xstate';\n\nexport const INITIAL_PACMAN_STATE = 'eating';\n\ninterface EventHandler {\n  onChasing(): void;\n  onDead(): void;\n}\n\ntype PacManContext = {};\n\ninterface PacManStateSchema {\n  states: {\n    eating: {};\n    chasing: {};\n    dead: {};\n  };\n}\n\nexport type PacManEventType =\n  | 'ENERGIZER_EATEN'\n  | 'ENERGIZER_TIMED_OUT'\n  | 'COLLISION_WITH_GHOST'\n  | 'REVIVED';\n\ntype PacManEvent = { type: PacManEventType };\n\nexport type PacManState = State<\n  PacManContext,\n  PacManEvent,\n  PacManStateSchema,\n  any\n>;\n\nconst PacManStateChart = Machine<PacManContext, PacManStateSchema, PacManEvent>(\n  {\n    id: 'pac-man',\n    initial: INITIAL_PACMAN_STATE,\n    states: {\n      eating: {\n        on: {\n          ENERGIZER_EATEN: 'chasing',\n          COLLISION_WITH_GHOST: 'dead',\n        },\n      },\n      chasing: {\n        entry: 'onChasing',\n        on: {\n          ENERGIZER_TIMED_OUT: 'eating',\n        },\n      },\n      dead: {\n        entry: 'onDead',\n        on: {\n          REVIVED: 'eating',\n        },\n      },\n    },\n  }\n);\n\nexport const makePacManStateChart = (eventHandler: EventHandler) => {\n  const extended = PacManStateChart.withConfig({\n    actions: {\n      onChasing: eventHandler.onChasing,\n      onDead: eventHandler.onDead,\n    },\n  });\n  const stateChart = interpret(extended);\n  return stateChart;\n};\n","import { observable, action, computed } from 'mobx';\n\nimport { Direction, MilliSeconds } from './Types';\nimport {\n  tileFromScreen,\n  screenFromTile,\n  TileCoordinates,\n  ScreenCoordinates,\n  assertValidTileCoordinates,\n} from './Coordinates';\nimport {\n  makePacManStateChart,\n  PacManEventType,\n  INITIAL_PACMAN_STATE,\n  PacManState,\n} from './PacManStateChart';\nimport { Game } from './Game';\nimport { StateValue } from 'xstate';\n\nexport class PacMan {\n  constructor(game: Game) {\n    this.game = game;\n\n    this.stateChart.onTransition(this.handleTransition);\n    this.stateChart.start();\n  }\n\n  @action.bound\n  handleTransition(state: PacManState) {\n    if (!state.changed) {\n      return;\n    }\n    this.stateChartState = state;\n  }\n\n  game: Game;\n\n  stateChart = makePacManStateChart({\n    onChasing: this.onChasing,\n    onDead: this.onDead,\n  });\n\n  @observable.ref\n  stateChartState: PacManState = this.stateChart.state;\n\n  @action.bound\n  onChasing() {\n    this.game.energizerTimer.start();\n  }\n\n  @action.bound\n  onDead() {\n    this.diedAtTimestamp = this.game.timestamp;\n  }\n\n  @computed\n  get dead(): boolean {\n    return this.stateChartState.matches('dead');\n  }\n\n  @computed\n  get state(): StateValue {\n    return this.stateChartState.value;\n  }\n\n  send(event: PacManEventType) {\n    this.stateChart.send(event);\n  }\n\n  @computed\n  get alive() {\n    return !this.dead;\n  }\n\n  @observable\n  screenCoordinates: ScreenCoordinates = screenFromTile({ x: 1, y: 1 });\n\n  @action\n  setTileCoordinates(tile: TileCoordinates) {\n    assertValidTileCoordinates(tile);\n    this.screenCoordinates = screenFromTile(tile);\n  }\n\n  @computed\n  get tileCoordinates(): TileCoordinates {\n    return tileFromScreen(this.screenCoordinates);\n  }\n\n  @observable\n  diedAtTimestamp: MilliSeconds = -1;\n\n  @computed\n  get timeSinceDeath(): MilliSeconds {\n    if (this.alive) {\n      return 0;\n    }\n    return this.game.timestamp - this.diedAtTimestamp;\n  }\n\n  @observable\n  extraLivesLeft = 2;\n\n  @observable\n  direction: Direction = 'RIGHT';\n  nextDirection: Direction = 'RIGHT';\n}\n\nexport const resetPacMan = (pacMan: PacMan) => {\n  pacMan.diedAtTimestamp = -1;\n  pacMan.stateChart.state.value = INITIAL_PACMAN_STATE;\n  pacMan.setTileCoordinates({ x: 14, y: 23 });\n  pacMan.nextDirection = 'LEFT';\n  pacMan.direction = 'LEFT';\n};\n","import { action, computed, observable } from 'mobx';\nimport { Ghost } from './Ghost';\nimport { makeGhosts, resetGhosts } from './makeGhosts';\nimport { Maze } from './Maze';\nimport { PacMan, resetPacMan } from './PacMan';\nimport { MilliSeconds, PixelsPerFrame } from './Types';\nimport { Store } from './Store';\nimport { TimeoutTimer } from './TimeoutTimer';\n\nexport const DEFAULT_SPEED = 2;\n\nconst ENERGIZER_DURATION: MilliSeconds = 5000;\n\nexport class Game {\n  constructor(store: Store) {\n    this.store = store;\n    this.pacMan = new PacMan(this);\n    this.ghosts = makeGhosts(this);\n  }\n\n  store: Store;\n\n  //** The timestamp we got from requestAnimationFrame().\n  @observable\n  externalTimeStamp: MilliSeconds | null = null;\n\n  @observable\n  timestamp: MilliSeconds = 0;\n\n  @observable\n  lastFrameLength: MilliSeconds = 17;\n\n  @observable\n  frameCount = 0;\n\n  @observable\n  gamePaused = false;\n\n  speed: PixelsPerFrame = DEFAULT_SPEED;\n\n  ghosts: Ghost[];\n\n  pacMan: PacMan;\n\n  @observable\n  score = 0;\n\n  @observable\n  killedGhosts = 0;\n\n  maze = new Maze();\n\n  @action.bound\n  revivePacMan() {\n    this.pacMan.send('REVIVED');\n    this.timestamp = 0;\n    resetPacMan(this.pacMan);\n    resetGhosts(this.ghosts);\n  }\n\n  @computed\n  get gameOver(): boolean {\n    const pacMan = this.pacMan;\n    return pacMan.dead && pacMan.extraLivesLeft === 0;\n  }\n\n  energizerTimer = new TimeoutTimer(ENERGIZER_DURATION, () => {\n    this.handleEnergizerTimedOut();\n  });\n\n  @action\n  handleEnergizerTimedOut() {\n    this.pacMan.send('ENERGIZER_TIMED_OUT');\n    for (const ghost of this.ghosts) {\n      ghost.send('ENERGIZER_TIMED_OUT');\n    }\n  }\n\n  readyGameForPlay() {\n    resetPacMan(this.pacMan);\n  }\n}\n","import { observable } from 'mobx';\nimport { Store } from './Store';\nimport { GhostViewOptions } from './GhostViewOptions';\nimport { PacManViewOptions } from '../pages/GamePage/components/PacManViewOptions';\nimport { GameViewOptions } from './GameViewOptions';\n\nexport class DebugState {\n  constructor(store: Store) {\n    this.store = store;\n  }\n\n  store: Store;\n\n  @observable\n  gameViewOptions: GameViewOptions = {\n    hitBox: false,\n  };\n\n  @observable\n  ghostViewOptions: GhostViewOptions = {\n    target: false,\n    wayPoints: false,\n  };\n\n  @observable\n  pacManViewOptions: PacManViewOptions = {\n    somePlaceholder: false,\n  };\n}\n","import { observable, action } from 'mobx';\nimport { Game } from './Game';\nimport { DebugState } from './DebugState';\n\nexport class Store {\n  @observable\n  game: Game = new Game(this);\n\n  debugState = new DebugState(this);\n\n  @action.bound\n  resetGame() {\n    this.game = new Game(this);\n    this.game.readyGameForPlay();\n  }\n}\n","import React, { FC, ComponentType } from 'react';\nimport 'antd/dist/antd.compact.css';\n\nimport './GlobalStyles.css';\nimport { BrowserRouter } from 'react-router-dom';\nimport { Routes } from './Routes';\nimport { AppMenu } from './components/AppMenu';\nimport { Store } from './model/Store';\nimport { StoreProvider } from './components/StoreContext';\n\nconst App: FC<{ store?: Store; Router?: ComponentType }> = ({\n  store = new Store(),\n  Router = BrowserRouter,\n}) => {\n  return (\n    <StoreProvider value={store}>\n      <Router>\n        <div className=\"App\">\n          <AppMenu />\n          <Routes />\n        </div>\n      </Router>\n    </StoreProvider>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\n// https://github.com/mobxjs/mobx-react-lite/tree/v2.0.5#observer-batching\nimport 'mobx-react-lite/batchingForReactDom';\n\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}